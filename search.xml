<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTPs证书相关</title>
    <url>/2018/03/25/HTTPS-certificate/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>去年某客户需要使用<code>HTTP/2</code>业务来做人工直播内容审核用。具体操作应该为一个大屏幕，一个chrome浏览器，浏览器使用<code>HTTP/2</code>可以复用一个连接，向节点同时请求几十路流，随后进行审核。</p>
<p>由于彼时公司所使用的cache软件和前端反向代理软件均不支持<code>HTTP/2</code>，所以在客户要求的区域，搭建了两台NGINX服务的机器，由客户使用hosts访问的形式进行服务。</p>
<p>近期该客户所使用的证书过期，而由于该两台机器为人工配置，未自动更新新的证书，导致该服务异常。而客服人员所提供的新的证书没有包含私钥，导致证书一度无法更新。</p>
<p>之前对于<code>HTTPs</code>业务一直未有真的接触，此次趁机学习一记。</p>
<a id="more"></a>

<h1 id="加密方式与应用"><a href="#加密方式与应用" class="headerlink" title="加密方式与应用"></a>加密方式与应用</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密的主要原理是，数据交互双方使用事先通过一定途径约定好的秘钥对需要传输的消息进行加密，并使用同样的秘钥对收到的加密消息进行解密。</p>
<p>由于使用的加解密的秘钥一样，所以称为对称加密。常见的对称加密方式有DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES等。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密区别于对称加密的一点是，数据交互双方持有的秘钥不一样，一般用户持有的秘钥称为公钥，而服务端持有的秘钥为私钥。公钥可以公开，服务端对于任何请求方都可以响应其公钥。而私钥只能是服务端持有。</p>
<p>当需要进行加密通信时，服务端将公钥提供给用户并携带一个随机数，用户利用公钥和随机数将需要传输的消息加密。服务端通过私钥解密，得到明文消息。</p>
<p>服务端对需要响应的消息利用hash算法生成摘要，并利用私钥将摘要加密，形成数字签名。当客户端收到响应后，利用公钥解开数字签名，得到摘要，然后对收到的消息利用同样的hash算法生成摘要，对比两者摘要是否相同。如果相同，则认为响应消息来自指定服务端。</p>
<p>常见的非对称加密有：RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法）。</p>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>非对称加解密的计算消耗要比对称加解密大很多，所以实际应用一般采用两者的结合达到速度和安全的两全其美。即：使用非对称机密方式传输对称加密的秘钥。用对称加密传输实际的消息。 </p>
<h2 id="CA-certificate-authority"><a href="#CA-certificate-authority" class="headerlink" title="CA, certificate authority"></a>CA, certificate authority</h2><p>剩下的问题是如何在在非对称加密时，把服务器的公钥传输给请求方了。若是直接传输，公钥在传输过程如果发生劫持被替换成其他公钥怎么办。</p>
<p>以上问题总结下来便是如何证明收到的公钥便是便是实际请求响应方给的呢。</p>
<p>此处引入一个数字摘要的概念。消息摘要是将公钥和其他证书申请者的信息作为hash输入（预映射）而得到的hash值。由于hash唯一性，如果中途被篡改，则相应的消息摘要将发生变化，无法校验通过。</p>
<p>为了防止中间劫持方修改整个公钥和其他预映射的信息，并生成新的消息摘要，服务端在提供消息摘要时，会使用有权威性的证书授权中心的私钥进行加密，而这些权威性的证书授权中心的公钥则预设在我们的操作系统或者浏览器中。当中途证书被劫持篡改后，将无法校验通过。</p>
<p>上述权威性的证书授权中心即所谓的CA,certificate authority，比较著名的有Symantec，GeoTrust和新兴的免费的Let’s Encrypt等。</p>
<h1 id="HTTPS交互"><a href="#HTTPS交互" class="headerlink" title="HTTPS交互"></a>HTTPS交互</h1><p>使用<code>cURL</code>发起一次<code>HTTPS</code>的请求，<code>cURL</code>记录的响应如下：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/curl-7.55.1/bin/curl --http2 --cacert /etc/pki/tls/certs/ca-bundle.crt https://pull-flv-l1-hs-admin.pstatp.com/live/livestream.flv -v</span><br><span class="line">*   Trying 110.242.21.20...</span><br><span class="line">* TCP_NODELAY <span class="built_in">set</span></span><br><span class="line">* Connected to pull-flv-l1-hs-admin.pstatp.com (110.242.21.20) port 443 (<span class="comment">#0)</span></span><br><span class="line">* ALPN, offering h2</span><br><span class="line">* ALPN, offering http/1.1</span><br><span class="line">* Cipher selection: ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH</span><br><span class="line">* successfully <span class="built_in">set</span> certificate verify locations:</span><br><span class="line">*   CAfile: /etc/pki/tls/certs/ca-bundle.crt</span><br><span class="line">  CApath: none</span><br><span class="line">* TLSv1.2 (OUT), TLS header, Certificate Status (22):</span><br><span class="line">* TLSv1.2 (OUT), TLS handshake, Client hello (1):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Server hello (2):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Certificate (11):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Server key exchange (12):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Server finished (14):</span><br><span class="line">* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):</span><br><span class="line">* TLSv1.2 (OUT), TLS change cipher, Client hello (1):</span><br><span class="line">* TLSv1.2 (OUT), TLS handshake, Finished (20):</span><br><span class="line">* TLSv1.2 (IN), TLS change cipher, Client hello (1):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Finished (20):</span><br><span class="line">* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256</span><br><span class="line">* ALPN, server accepted to use h2</span><br><span class="line">* Server certificate:</span><br><span class="line">*  subject: CN=*.pstatp.com</span><br><span class="line">*  start date: Dec 21 00:00:00 2017 GMT</span><br><span class="line">*  expire date: Dec 26 12:00:00 2020 GMT</span><br><span class="line">*  subjectAltName: host <span class="string">"pull-flv-l1-hs-admin.pstatp.com"</span> matched cert<span class="string">'s "*.pstatp.com"</span></span><br><span class="line"><span class="string">*  issuer: C=US; O=DigiCert Inc; OU=www.digicert.com; CN=RapidSSL RSA CA 2018</span></span><br><span class="line"><span class="string">*  SSL certificate verify ok.</span></span><br><span class="line"><span class="string">* Using HTTP2, server supports multi-use</span></span><br><span class="line"><span class="string">* Connection state changed (HTTP/2 confirmed)</span></span><br><span class="line"><span class="string">* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0</span></span><br><span class="line"><span class="string">* Using Stream ID: 1 (easy handle 0x10cc020)</span></span><br><span class="line"><span class="string">&gt; GET /live/livestream.flv HTTP/2</span></span><br><span class="line"><span class="string">&gt; Host: pull-flv-l1-hs-admin.pstatp.com</span></span><br><span class="line"><span class="string">&gt; User-Agent: curl/7.55.1</span></span><br><span class="line"><span class="string">&gt; Accept: */*</span></span><br><span class="line"><span class="string">&gt; </span></span><br><span class="line"><span class="string">* Connection state changed (MAX_CONCURRENT_STREAMS updated)!</span></span><br><span class="line"><span class="string">&lt; HTTP/2 200 </span></span><br><span class="line"><span class="string">&lt; date: Sun, 25 Mar 2018 03:08:54 GMT</span></span><br><span class="line"><span class="string">&lt; content-type: video/x-flv</span></span><br><span class="line"><span class="string">&lt; cache-control: no-cache</span></span><br><span class="line"><span class="string">&lt; expires: -1</span></span><br><span class="line"><span class="string">&lt; pragma: no-cache</span></span><br><span class="line"><span class="string">&lt; </span></span><br><span class="line"><span class="string">Warning: Binary output can mess up your terminal. Use "--output -" to tell </span></span><br><span class="line"><span class="string">Warning: curl to output it to your terminal anyway, or consider "--output </span></span><br><span class="line"><span class="string">Warning: &lt;FILE&gt;" to save to a file.</span></span><br><span class="line"><span class="string">* Failed writing body (0 != 13)</span></span><br><span class="line"><span class="string">* Closing connection 0</span></span><br><span class="line"><span class="string">* TLSv1.2 (OUT), TLS alert, Client hello (1):</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>cURL</code>在tcp建联后，进入了<code>TLSv1.2</code>的SSL层数据交互。</p>
<p>首先Client端发起<code>Client Hello</code>，会提供4字节的unix时间和用于后续使用的28字节随机数<code>random_C</code>。并且会携带客户端支持所有加密套件(Cipher Suites)名称，以供服务器选择，如下图一所示。</p>
<p><img src="/images/20180325001.png" alt="图一"></p>
<center>图一</center>

<p>并且可能会在扩展信息(Extension)中携带请求URL的<code>server name</code>信息，方便服务器决定使用哪本SNI证书。关于SNI证书，可以查看<a href="https://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">维基百科</a>。请求如下图二所示。</p>
<p><img src="/images/20180325002.png" alt="图二"></p>
<center>图二</center>

<p>服务端收到<code>Client Hello</code>后会相应响应给客户端<code>Server Hello</code>，会提供服务端的4字节的unix时间和用于后续使用的28字节随机数<code>random_S</code>，并且选定客户端提供的支持的加密套件中的一种，如下图三中所示，选择是<code>**TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256**</code>，其具体的含义为：</p>
<ul>
<li><p>基于<code>TLS</code>协议；</p>
</li>
<li><p>使用ECDHE作为秘钥交换算法；</p>
</li>
<li><p>RSA作为签名认证；</p>
</li>
<li><p>AES_128_GCM作为对称加密算法；</p>
</li>
<li><p>SHA256作为摘要算法；</p>
</li>
</ul>
<p>再深入的信息，估计是要看几本大部头的书才能理解了。</p>
<p><img src="/images/20180325003.png" alt="图三"></p>
<center>图三</center>

<p>服务端在发送<code>Server Hello</code>之后，便会将相关的证书（包含公钥）发送给客户端，该操作称为<code>Certificate</code>，如下图四所示，其中包含的证书信息如下图五所示。</p>
<p><img src="/images/20180325004.png" alt="图四"></p>
<center>图四</center>

<p><img src="/images/20180325005.png" alt="图五"></p>
<center>图五</center>

<p>此次加密通信中，使用的是<code>ECDHE</code>算法作为秘钥交换算法。所以服务端在发送<code>Certificate</code>消息后还会给出用于<code>ECDHE</code>加密使用的信息，称作<code>Server Key Exchange</code>。如下图六，服务端提供了加密算法所需的Pubkey以及对数据做了一次签名。</p>
<p><img src="/images/20180325006.png" alt="图六"></p>
<center>图六</center>

<p>到此，服务端所需传递的数据均已完成，服务端发送一个<code>Server Hello done</code>消息，表示完成。如下图七。</p>
<p><img src="/images/20180325007.png" alt="图七"></p>
<center>图七</center>

<p>接下来轮到客户端表演了。在收到服务端的<code>Server Key Exchange</code>之后，客户端会进行秘钥交换，做相应的<code>Client Key Exchange</code>动作，交换一些加密参数。如下图八。</p>
<p>此时，不出意外，服务端和客户端就可以进行加密通信了。客户端发送<code>ChangeCipher Spec</code>消息，表示接下来开始加密通信，随后发送一个加密的握手消息<code>Encrypted Handshake Message</code>进行验证。如下图八。</p>
<p><img src="/images/20180325008.png" alt="图八"></p>
<center>图八</center>



<p>服务端收到客户端开始加密通信的消息和加密的握手消息后，相应的也响应一个开始加密通信的消息<code>Change Cipher Spec</code>，并且也发送一个加密的握手消息<code>Encrypted Handshake Message</code>。如图十所示。</p>
<p><img src="/images/20180325009.png" alt="图九"></p>
<center>图九</center>



<p>至此，加密通道完成建立，开始进行加密通信。直到客户端发起<code>Encrypted Alert</code>，表示结束为止。</p>
<p>总结下来的流程图大致如此：</p>
<div id="sequence-0"></div>

<p>详细的加密算法基本也不用了解。太高深了。</p>
<h1 id="NGINX证书配置"><a href="#NGINX证书配置" class="headerlink" title="NGINX证书配置"></a>NGINX证书配置</h1><p>NGINX作为proxy使用时的相关配置。</p>
<p>对外域名为<code>pull.test.com</code>，启用<code>HTTP</code>和<code>HTTPS</code>，并且启用<code>HTTP2</code>，</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">server_name</span> pull.test.com;</span><br><span class="line">	<span class="attribute">listen</span> [::]:<span class="number">443</span> ssl http2 reuseport;</span><br><span class="line">	<span class="attribute">listen</span> [::]:<span class="number">80</span> http2 reuseport; </span><br><span class="line">	<span class="attribute">ssl_certificate</span> /SSL_cert/test.com.crt;</span><br><span class="line">	<span class="attribute">ssl_certificate_key</span> /SSL_cert/test.com.key;</span><br><span class="line">	<span class="attribute">ssl_trusted_certificate</span> /SSL_cert/test.com.ca;    </span><br><span class="line">	<span class="attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK; </span><br><span class="line">	            </span><br><span class="line">	<span class="attribute">location</span> / &#123;</span><br><span class="line">		<span class="attribute">set</span> <span class="variable">$s_host</span> ori.pull.test.com;</span><br><span class="line">		<span class="attribute">proxy_set_header</span> Host <span class="variable">$s_host</span>;</span><br><span class="line">		<span class="attribute">more_set_headers</span> <span class="string">"Access-Control-Allow-Origin:*"</span>;</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://127.0.0.1:xxx;</span><br><span class="line">	&#125;</span><br><span class="line">	//test URL</span><br><span class="line">	<span class="attribute">location</span> = /live/livestream.flv &#123;</span><br><span class="line">		<span class="attribute">set</span> <span class="variable">$s_host</span> test.test.com;</span><br><span class="line">		proxy_set_header Host $s_host;d</span><br><span class="line">		<span class="attribute">proxy_pass</span> http://127.0.0.1:xxx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">Client->Server: Client Hello
Server->Client: Server Hello
Server->Client: Certificate
Server->Client: Server Key Exchange
Server->Client: Server Hello Done
Client->Server: Client Key Exchange
Client->Server: Change Cipher Spec
Client->Server: Encrypted Handshake Message
Server->Client: Change Cipher Spec
Server->Client: Encrypted Handshake Message
Client->Server: Application Data
Server->Client: Application Data
Client-->Server: ...
Server-->Client: ...
Client->Server: Encrypted Alert</textarea><textarea id="sequence-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script>]]></content>
      <tags>
        <tag>HTTPS</tag>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux+Nginx+MariaDB+PHP_SERVER_BUILDING</title>
    <url>/2017/01/03/Linux-Nginx-MariaDB-PHP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Linux+Nginx+MariaDB+PHP,LNMP架构的动态网站服务器是比较流行的web服务器整体结构方案，由前几年比较流行的LAMP（Linux+Apache+Mysql+PHP）发展而来。其中将Apache替换成对硬件要求更低，并发数更高并且开源的Nginx；将被Oracle收购了的Mysql换成了完全兼容Mysql的MariaDB；其他不变。 </p>
<a id="more"></a>   
<p>本次突发奇想决定玩一下PHP，所以在VPS上搭了个LNMP环境。</p>
<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><p>选择VPS提供商镜像。KVM架构的VPS也可以自行安装各大Linux发行版。<br>此处安装的是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/redhat-release </span></span><br><span class="line">CentOS release 6.6 (Final)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># uname -a  </span></span><br><span class="line">Linux LA 2.6.32-042stab113.21 <span class="comment">#1 SMP Wed Mar 23 11:05:25 MSK 2016 i686 i686 i386 GNU/Linux</span></span><br></pre></td></tr></table></figure>

<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>VPS提供的镜像的yum源的各个软件版本都较低，为了安装更新版的nginx，此处选择自行编译源码安装nginx。<br>此处nginx安装参考<a href="http://www.cnblogs.com/freeweb/p/5341926.html" target="_blank" rel="noopener"><strong><em>这篇博客</em></strong></a></p>
<p>需要首先安装<code>gcc</code>、<code>gcc-c++</code>、<code>openssl</code>此处选择简单的yum安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y gcc gcc-c++ openssl</span><br></pre></td></tr></table></figure>
<p>下载nginx源码和其所需的PCRE库与zlib库源码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir nginx</span><br><span class="line"><span class="built_in">cd</span> nginx</span><br><span class="line">wget http://nginx.org/download/nginx-1.8.1.tar.gz</span><br><span class="line">wget ftp://ftp.csx.cam.ac.uk/pub/software/programming/pcre/pcre-8.38.tar.gz</span><br><span class="line">wget https://ncu.dl.sourceforge.net/project/libpng/zlib/1.2.8/zlib-1.2.8.tar.gz</span><br><span class="line">tar zxvf nginx-1.8.1.tar.gz</span><br><span class="line">tar zxvf pcre-8.38.tar.gz</span><br><span class="line">tar zxvf zlib-1.2.8.tar.gz</span><br></pre></td></tr></table></figure>
<p>编译安装nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> nginx-1.8.1</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/nginx --sbin-path=/usr/<span class="built_in">local</span>/nginx/nginx --conf-path=/usr/<span class="built_in">local</span>/nginx/nginx.conf --pid-path=/usr/<span class="built_in">local</span>/nginx/nginx.pid --with-http_ssl_module --with-pcre=../pcre-8.38 --with-zlib=../zlib-1.2.8</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装目录以及其他配置等目录可以自定义。<br><code>--with-pcre=</code>和<code>--with-zlib=</code>源码路径根据实际填写。<br>直接启动<code>/usr/local/nginx/nginx</code>即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://localhost</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><img src="/images/20170103_2.png" alt="nginx"><br>表示安装成功。如果未成功，请查看80端口是否占用，或者使用其他端口。<br><code>/usr/local/nginx/nginx</code>有一下几个参数选择，可自行研究。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Options:</span><br><span class="line">  -?,-h         : this <span class="built_in">help</span>    </span><br><span class="line">  -v            : show version and <span class="built_in">exit</span>   </span><br><span class="line">  -V            : show version and configure options <span class="keyword">then</span> <span class="built_in">exit</span></span><br><span class="line">  -t            : <span class="built_in">test</span> configuration and <span class="built_in">exit</span></span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : <span class="built_in">set</span> prefix path (default: /usr/<span class="built_in">local</span>/nginx/)</span><br><span class="line">  -c filename   : <span class="built_in">set</span> configuration file (default: /usr/<span class="built_in">local</span>/nginx/nginx.conf)</span><br><span class="line">  -g directives : <span class="built_in">set</span> global directives out of configuration file</span><br></pre></td></tr></table></figure>
<p>可以在<code>/etc/rc.local</code>中添加开机启动</p>
<h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><p>此处MariaDB安装参考<a href="http://www.cnblogs.com/freeweb/p/5425554.html" target="_blank" rel="noopener"><strong><em>这篇博客</em></strong></a><br>下载PHP源码，解压。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://cn2.php.net/distributions/php-7.1.0.tar.gz</span><br><span class="line">tar zxvf php-7.1.0.tar.gz</span><br></pre></td></tr></table></figure>
<p>安装PHP的各类依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install libxml2 libxml2-devel openssl openssl-devel curl curl-devel libjpeg install libjpeg-devel install libpng install libpng-devel install freetype install freetype-devel install pcre install pcre-devel install libxslt install libxslt-devel</span><br></pre></td></tr></table></figure>
<p>编译安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> php-7.1.0</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/php --with-curl --with-freetype-dir --with-gd --with-gettext --with-iconv-dir --with-kerberos --with-libdir=lib64 --with-libxml-dir --with-mysqli --with-openssl --with-pcre-regex --with-pdo-mysql --with-pdo-sqlite --with-pear --with-png-dir --with-jpeg-dir --with-xmlrpc --with-xsl --with-zlib --with-bz2 --with-mhash --<span class="built_in">enable</span>-fpm --<span class="built_in">enable</span>-bcmath --<span class="built_in">enable</span>-libxml --<span class="built_in">enable</span>-inline-optimization --<span class="built_in">enable</span>-gd-native-ttf --<span class="built_in">enable</span>-mbregex --<span class="built_in">enable</span>-mbstring --<span class="built_in">enable</span>-opcache --<span class="built_in">enable</span>-pcntl --<span class="built_in">enable</span>-shmop --<span class="built_in">enable</span>-soap --<span class="built_in">enable</span>-sockets --<span class="built_in">enable</span>-sysvsem --<span class="built_in">enable</span>-sysvshm --<span class="built_in">enable</span>-xml --<span class="built_in">enable</span>-zip</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>注意编译时间较久。<br>接下来配置PHP和nginx。首先从PHP源码目录中复制默认配置到相应目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp php.ini-development /usr/<span class="built_in">local</span>/php/php.ini</span><br><span class="line">cp /usr/<span class="built_in">local</span>/php/etc/php-fpm.conf.default /usr/<span class="built_in">local</span>/php/etc/php-fpm.conf</span><br><span class="line">cp sapi/fpm/php-fpm /usr/<span class="built_in">local</span>/bin</span><br></pre></td></tr></table></figure>
<p>创建web用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd www-data</span><br><span class="line">useradd -g www-data www-data</span><br></pre></td></tr></table></figure>
<p>修改<code>php-fpm.conf</code>中包含的<code>php-fpm.d</code>目录实际路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/php/etc/php-fpm.conf</span><br></pre></td></tr></table></figure>
<p>修改其中包含配置的路径<code>include=NONE/etc/php-fpm.d/*.conf</code>为<code>/usr/local/php/etc/php-fpm.d/</code>下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/php/etc/php-fpm.d/www.conf.default /usr/<span class="built_in">local</span>/php/etc/php-fpm.d/www.conf</span><br><span class="line">vim /usr/<span class="built_in">local</span>/php/etc/php-fpm.d/www.conf</span><br></pre></td></tr></table></figure>
<p>添加用户名和用户组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user = www-data</span><br><span class="line">group = www-data</span><br></pre></td></tr></table></figure>
<p>接下来修改nginx配置<code>vim /usr/local/nginx/nginx.conf</code>。修改nginx的运行用户和用户组为<code>www-data：www-data</code>。在<code>server{}</code>中的<code>location / {}</code>模块中加入<code>index.php</code>项，并删除释掉启动<code>location ~* \.php$ {}</code>模块，使php生效。修改<code>fastcgi</code>路径<code>fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user www-data www-data;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">location / &#123;</span><br><span class="line">    root   html;</span><br><span class="line">    index  index.html index.htm index.php;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">location ~ \.php$ &#123;</span><br><span class="line">    root           html;</span><br><span class="line">    fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line">    <span class="comment">#fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    fastcgi_param  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">    include        fastcgi_params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动nginx和php-fpm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/nginx/nginx -s restart</span><br><span class="line">/usr/<span class="built_in">local</span>/bin/php-fpm</span><br></pre></td></tr></table></figure>
<p>可通过查看php-fpm的9000端口是否在监听来判断php-fpm是否启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># netstat -tln | grep 9000</span></span><br><span class="line">tcp        0      0 127.0.0.1:9000              0.0.0.0:*                   LISTEN</span><br></pre></td></tr></table></figure>
<p>接下里一般会在nginx的<code>html</code>目录下新建一个<code>vim info.php</code>来验证php能否正好解析。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    phpinfo();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>访问<code>http://ip/info.php</code>可以看到安装的php的版本和支持库之类的信息。<br><img src="/images/20170103.png" alt="phpinfo"></p>
<h1 id="MariaDB"><a href="#MariaDB" class="headerlink" title="MariaDB"></a>MariaDB</h1><p>MariaDB是Mysql的一个分支，目前还是完全兼容Mysql的，所以在安装的时候目录和名称依然采用mysql的名字。<br>此处MariaDB安装参考<a href="http://www.cnblogs.com/freeweb/p/5991374.html" target="_blank" rel="noopener"><strong><em>这篇博客</em></strong></a><br>下载MariaDB源码，并解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir mariadb</span><br><span class="line"><span class="built_in">cd</span> mariadb</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/mariadb//mariadb-10.1.20/<span class="built_in">source</span>/mariadb-10.1.20.tar.gz</span><br><span class="line">tar zxvf mariadb-10.1.20.tar.gz</span><br></pre></td></tr></table></figure>
<p>yum安装MariaDB依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install readline-devel zlib-devel openssl-devel libaio-devel</span><br></pre></td></tr></table></figure>
<p>数据库设计到原始数据，所以一般需要新建专用的用户和用户来运行。这里新建<code>mysql：mysql</code>用户和用户组，并不允许ssh远程登录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd -r mysql			<span class="comment">#创建系统用户组</span></span><br><span class="line">useradd -g mysql -s /sbin/nologin mysql	<span class="comment">#创建用户，归属于mysql组，不允许远程登录</span></span><br></pre></td></tr></table></figure>
<p>接下来创建数据库目录，并更改为拥有者。此处将数据库数据存放在<code>/data/mysql</code>目录中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /data/mysql</span><br><span class="line">chown -R mysql:mysql /data/mysql/</span><br></pre></td></tr></table></figure>
<p>现在可以安装MariaDB了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> mariadb-10.1.20</span><br><span class="line">cmake . -DCMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span>/mysql -DMYSQL_DATADIR=/data/mysql -DSYSCONFDIR=/etc -DWITHOUT_TOKUDB=1 -DMYSQL_UNIX_ADDR=/tmp/mysql.sock -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>此处编译时间较长，需要耐心等待，若出现编译失败的情况，请删除目录下的编译缓存文件<code>CMakeCache.txt</code>后，更改相关依赖关系重新编译。<br>安装成功后，进入安装目录，初始化mysql服务器，并安装服务到系统服务中，设置开机启动服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql/</span><br><span class="line">chown -R mysql:mysql *</span><br><span class="line">scripts/mysql_install_db --user=mysql</span><br><span class="line">cp support-files/mysql.server /etc/init.d/mysqld</span><br><span class="line">chkconfig --add mysqld	<span class="comment"># 添加至系统服务</span></span><br><span class="line">chkconfig mysqld on	<span class="comment"># 设置开机自启动</span></span><br></pre></td></tr></table></figure>
<p>最后将<code>/var/lib/mysql/mysql.sock</code>链接到<code>/tmp/mysql.sock</code>，否者无法进入mysql。启动mysql服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /var/lib/mysql/mysql.sock /tmp/mysql.sock</span><br><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>
<p>后续操作参考mysql入门教程。</p>
]]></content>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title>网卡缓冲值问题-续</title>
    <url>/2017/12/23/NIC-buffer-issue-Cotinued/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用<code>ip</code>命令查看网状态。<code>ifconfig</code>命令已多年不再更新，从CentOS7开始，发行版的mini系统已不再自带<code>ifconfig</code>工具，取而代之的是<code>ip</code>命令。</p>
<p>其实质是<code>iproute2</code>套件取代了<code>net-tools</code>套件，<code>ifconfig</code>便是后者中一个工具。两者的简单对比，从网上找到张图：</p>
<p><img src="/images/20171223003.png" alt="iproute2 vs net-tools"></p>
<a id="more"></a>

<h1 id="查看网卡统计数据"><a href="#查看网卡统计数据" class="headerlink" title="查看网卡统计数据"></a>查看网卡统计数据</h1><p>使用<code>ip -s link</code>查看link的统计数据：</p>
<p><img src="/images/20171223002.jpg" alt="网卡状态"></p>
<p>以上各个统计指标的含义为：</p>
<table>
<thead>
<tr>
<th><strong>指标</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>errors</code></td>
<td>网线损坏或者网卡协商模式错误或者速率不匹配导致的错误。</td>
</tr>
<tr>
<td><code>dropped</code></td>
<td><code>iptables</code>或者其他规则或者内核读取网卡数据的buffer满导致的丢包。</td>
</tr>
<tr>
<td><code>overrun</code></td>
<td>网卡的驱动buffer满导致的overruns。</td>
</tr>
<tr>
<td><code>carrier</code></td>
<td>网线接触不良或者网线损坏或者交换机故障。</td>
</tr>
<tr>
<td><code>collsns</code></td>
<td>一般而言是0。若非零，代表双工模式的协商问题。若数值很小且不再增长，代表只是刚接入的时候故障，现已正常。</td>
</tr>
</tbody></table>
<h1 id="网卡buffer"><a href="#网卡buffer" class="headerlink" title="网卡buffer"></a>网卡buffer</h1><h2 id="网卡buffer设置"><a href="#网卡buffer设置" class="headerlink" title="网卡buffer设置"></a>网卡buffer设置</h2><p>上篇已提到，在网卡统计中出现overruns时，需要确定是否是由于网卡buffer设置不当导致的。使用<code>ethtool -g eth0</code>查看当前设置，具体<a href="/2017/12/17/NIC-buffer-issue/">查看上篇</a>。</p>
<p><img src="/images/20171223004.png" alt="网卡buffer查看"></p>
<p>值得说明的是，此处的数值大小并不是代表可以缓冲多大的数据，而是指可以缓冲的数据帧(frame)的数量。</p>
<h2 id="网卡buffer工作原理"><a href="#网卡buffer工作原理" class="headerlink" title="网卡buffer工作原理"></a>网卡buffer工作原理</h2><p>网卡buffer会采用环形缓冲(ring buffer)的形式，其也是FIFO的一种实现方式，设计非常简单，也比较稳定，在较为底层的数据传输中使用广泛。其工作原理大致如下图所示，具体可以查看<a href="https://en.wikipedia.org/wiki/Circular_buffer" target="_blank" rel="noopener">wiki</a>。</p>
<p><img src="/images/20171223001.gif" alt="ring buffer工作原理"></p>
<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p>有两个需要注意的地方：</p>
<h3 id="buffer设置"><a href="#buffer设置" class="headerlink" title="buffer设置"></a>buffer设置</h3><p>使用<code>ethtool -G  eth0 rx 256</code>设置接收buffer后，NIC会有个down/up的操作，会出现瞬时的断网，在网卡吞吐量较大时，副作用明显。</p>
<p>另外每次系统重启之后，该设置会失效，需要将该设置命令写入开机启动脚本<code>/etc/rc.local</code>中。</p>
<h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><p>网卡的buffer并不是越多越好，在接入带宽较低的情况下，设置很大的带宽导致数据包传输的延迟。</p>
<p>如在1Mbps接入带宽，MTU=1500字节的情况下，设置tx buffer=256帧。假设每个包刚好都是1500字节，则填充满buffer需要1500*256=384,000字节，也就是3,072,000比特。1Mbps每秒最多传输1024*1024=1,048,000比特的数据，当最新的一个包进入到buffer的时候，需要3s才能发送出去，会造成3s的数据延迟。</p>
<p>在有巨型帧(Jumbo Frame)时，每个帧长度更长，导致需要更多的时间充满buffer，延迟更久。</p>
<h2 id="内核参数"><a href="#内核参数" class="headerlink" title="内核参数"></a>内核参数</h2><p>以上所说的buffer均指的是网卡及其驱动程序所使用的buffer，另外还有个内核使用的buffer，用以从网卡读取数据帧所用，在内核参数中设置。</p>
<h3 id="BQL"><a href="#BQL" class="headerlink" title="BQL"></a>BQL</h3><p>此处有个概念叫<a href="https://en.wikipedia.org/wiki/Starvation_(computer_science)" target="_blank" rel="noopener"><strong>starvation</strong></a>，中文有翻译成<em>饿死</em>，即网卡从ring buffer读取数据的时候，buffer中没有数据，次时设备空转一次，造成浪费，称为<strong>starvation</strong>。避免<strong>starvation</strong>是个十分复杂的问题，一个有效的办法便是增大ring buffer的长度，使得内核可以存放跟多的数据到队列中，减少<strong>starvation</strong>产生的概率。</p>
<p>但是增大ring buffer长度可能会导致上节中描述的发包延迟现象，因此出现了<strong>BQL</strong>。</p>
<p>在<strong>3.3.0</strong>内核之后，linux 内核自身会通过<strong>字节队列限制</strong>(<strong>Byte Queue Limits,BQL</strong>)自动调整数据包排队的数量，以避免在ring buffer中排队的数据包太多导致的发送延迟。实质上是在IP栈和drive queue之间加了一层，对进入drive queue的数据进行调度，避免队列满而导致延迟，同时也减少buffer长度。</p>
<p>这边有些相关资料，留作备份，暂时看不懂，也没需求，先不看了。</p>
<p><a href="https://www.linuxplumbersconf.org/2012/wp-content/uploads/2012/08/bql_slide.pdf" target="_blank" rel="noopener">https://www.linuxplumbersconf.org/2012/wp-content/uploads/2012/08/bql_slide.pdf</a></p>
<p><a href="http://www.linuxplumbersconf.org/2011/ocw/sessions/171" target="_blank" rel="noopener">http://www.linuxplumbersconf.org/2011/ocw/sessions/171</a></p>
<h3 id="proc-sys-net"><a href="#proc-sys-net" class="headerlink" title="/proc/sys/net"></a>/proc/sys/net</h3><p>IP栈允许到ring buffer排队的数据包数量可以在<code>proc/sys/net/core/netdev_max_backlog</code>中设置。另外在<code>/proc/sys/net</code>和<code>/etc/sysctl.conf</code>中有很多网络相关的内核参数，具体可以参考<a href="https://www.cnblogs.com/fczjuever/archive/2013/04/17/3026694.html" target="_blank" rel="noopener">这篇博文</a>。</p>
<table>
<thead>
<tr>
<th><strong>参数（路径+文件）</strong></th>
<th><strong>描述</strong></th>
<th><strong>默认值</strong></th>
<th><strong>优化值</strong></th>
</tr>
</thead>
<tbody><tr>
<td>/proc/sys/net/core/rmem_default</td>
<td>默认的TCP数据接收窗口大小（字节）。</td>
<td>229376</td>
<td>256960</td>
</tr>
<tr>
<td>/proc/sys/net/core/rmem_max</td>
<td>最大的TCP数据接收窗口（字节）。</td>
<td>131071</td>
<td>513920</td>
</tr>
<tr>
<td>/proc/sys/net/core/wmem_default</td>
<td>默认的TCP数据发送窗口大小（字节）。</td>
<td>229376</td>
<td>256960</td>
</tr>
<tr>
<td>/proc/sys/net/core/wmem_max</td>
<td>最大的TCP数据发送窗口（字节）。</td>
<td>131071</td>
<td>513920</td>
</tr>
<tr>
<td>/proc/sys/net/core/netdev_max_backlog</td>
<td>在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</td>
<td>1000</td>
<td>2000</td>
</tr>
<tr>
<td>/proc/sys/net/core/somaxconn</td>
<td>定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数。</td>
<td>128</td>
<td>2048</td>
</tr>
<tr>
<td>/proc/sys/net/core/optmem_max</td>
<td>表示每个套接字所允许的最大缓冲区的大小。</td>
<td>20480</td>
<td>81920</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_mem</td>
<td>确定TCP栈应该如何反映内存使用，每个值的单位都是内存页（通常是4KB）。第一个值是内存使用的下限；第二个值是内存压力模式开始对缓冲区使用应用压力的上限；第三个值是内存使用的上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的BDP可以增大这些值（注意，其单位是内存页而不是字节）。</td>
<td>94011  125351  188022</td>
<td>131072  262144  524288</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_rmem</td>
<td>为自动调优定义socket使用的内存。第一个值是为socket接收缓冲区分配的最少字节数；第二个值是默认值（该值会被rmem_default覆盖），缓冲区在系统负载不重的情况下可以增长到这个值；第三个值是接收缓冲区空间的最大字节数（该值会被rmem_max覆盖）。</td>
<td>4096  87380  4011232</td>
<td>8760  256960  4088000</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_wmem</td>
<td>为自动调优定义socket使用的内存。第一个值是为socket发送缓冲区分配的最少字节数；第二个值是默认值（该值会被wmem_default覆盖），缓冲区在系统负载不重的情况下可以增长到这个值；第三个值是发送缓冲区空间的最大字节数（该值会被wmem_max覆盖）。</td>
<td>4096  16384  4011232</td>
<td>8760  256960  4088000</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_keepalive_time</td>
<td>TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。</td>
<td>7200</td>
<td>1800</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_keepalive_intvl</td>
<td>探测消息未获得响应时，重发该消息的间隔时间（秒）。</td>
<td>75</td>
<td>30</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_keepalive_probes</td>
<td>在认定TCP连接失效之前，最多发送多少个keepalive探测消息。</td>
<td>9</td>
<td>3</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_sack</td>
<td>启用有选择的应答（1表示启用），通过有选择地应答乱序接收到的报文来提高性能，让发送者只发送丢失的报文段，（对于广域网通信来说）这个选项应该启用，但是会增加对CPU的占用。</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_fack</td>
<td>启用转发应答，可以进行有选择应答（SACK）从而减少拥塞情况的发生，这个选项也应该启用。</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_timestamps</td>
<td>TCP时间戳（会在TCP包头增加12个字节），以一种比重发超时更精确的方法（参考RFC 1323）来启用对RTT 的计算，为实现更好的性能应该启用这个选项。</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_window_scaling</td>
<td>启用RFC 1323定义的window scaling，要支持超过64KB的TCP窗口，必须启用该值（1表示启用），TCP窗口最大至1GB，TCP连接双方都启用时才生效。</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_syncookies</td>
<td>表示是否打开TCP同步标签（syncookie），内核必须打开了CONFIG_SYN_COOKIES项进行编译，同步标签可以防止一个套接字在有过多试图连接到达时引起过载。</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_tw_reuse</td>
<td>表示是否允许将处于TIME-WAIT状态的socket（TIME-WAIT的端口）用于新的TCP连接 。</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_tw_recycle</td>
<td>能够更快地回收TIME-WAIT套接字。</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_fin_timeout</td>
<td>对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间（秒）。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。</td>
<td>60</td>
<td>30</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/ip_local_port_range</td>
<td>表示TCP/UDP协议允许使用的本地端口号</td>
<td>32768  61000</td>
<td>1024  65000</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_max_syn_backlog</td>
<td>对于还未获得对方确认的连接请求，可保存在队列中的最大数目。如果服务器经常出现过载，可以尝试增加这个数字。</td>
<td>2048</td>
<td>2048</td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_low_latency</td>
<td>允许TCP/IP栈适应在高吞吐量情况下低延时的情况，这个选项应该禁用。</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_westwood</td>
<td>启用发送者端的拥塞控制算法，它可以维护对吞吐量的评估，并试图对带宽的整体利用情况进行优化，对于WAN 通信来说应该启用这个选项。</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>/proc/sys/net/ipv4/tcp_bic</td>
<td>为快速长距离网络启用Binary Increase Congestion，这样可以更好地利用以GB速度进行操作的链接，对于WAN通信应该启用这个选项。</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.coverfire.com/articles/queueing-in-the-linux-network-stack/" target="_blank" rel="noopener">QUEUEING IN THE LINUX NETWORK STACK</a></p>
<p>这边文章包罗了很多内容，非常值得细度。</p>
]]></content>
      <tags>
        <tag>LINUX</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>网卡缓冲值问题</title>
    <url>/2017/12/17/NIC-buffer-issue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近期遇到一台推流的机器，反馈推流卡顿，查看确实整体丢帧率较高。但机器性能正常，未见明显跑高现象。<code>ifconfig</code>发现网卡<code>dropped</code>和<code>overruns</code>高，并且有持续增高的现象。</p>
<p><img src="%5Cimages%5C20171217001.png" alt="丢卡丢包"></p>
<p>确认交换机以及网线无异常后，最终发现网卡缓存值设置过小，导致在大量接收数据的情况下，出现overruns的现象。</p>
 <a id="more"></a>

<h1 id="网络逻辑模型"><a href="#网络逻辑模型" class="headerlink" title="网络逻辑模型"></a>网络逻辑模型</h1><p>半路出家，对于网络的东西一直一知半解，顺便学习下网络模型吧。</p>
<p>网络的逻辑模型，最近在豆瓣读书看到一个很好的介绍，<a href="https://read.douban.com/column/1788114/" target="_blank" rel="noopener">点击阅读</a>，想不到豆瓣也有技术文章。</p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>各种物理信号，如电压、亮度，振幅等表示0101010的二进制信息。</p>
<h2 id="链接层"><a href="#链接层" class="headerlink" title="链接层"></a>链接层</h2><p>也称为数据链路层，通过物理寻址，将比特流转化为逻辑数据，使用到mac地址。将比特流包装为帧，帧中包含有来源地址(Source, SRC)和目的地址(Destination, DST)，能够探测错误的校验序列(Frame Check Sequence)、数据区 (payload)与数据相配套的数据类型(Type)信息。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>通过网关(gateway)（通常由路由器或者三层交换机实现），改写帧的格式，将一个子网的数据帧转发到另一个子网，实现不同子网之间的通信，使用到IP地址。 </p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>进程间通信，如TCP和UDP使用端口号区分不同进程。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>HTTP，FTP等，更为高级的有各个程序自定义的逻辑。</p>
<h1 id="网卡收包功能"><a href="#网卡收包功能" class="headerlink" title="网卡收包功能"></a>网卡收包功能</h1><p>网卡是物理层和数据链路层设备。由于发数据基本不会出现丢包的现象，此处支持收数据的问题。</p>
<p>网卡接收到帧数据后，首先根据头部的序言(preamble)（用于调整时钟）、帧的起始信号(SFD, start frame delimiter)、目的地(DST, destination)和发出地(SRC, source)、类型(Type)和尾部的校验序列(CRC)（用于校验数据是否完整）这些信息进行校验，随后通过硬中断将帧copy到内存，交由内核处理。</p>
<h1 id="网卡缓冲值"><a href="#网卡缓冲值" class="headerlink" title="网卡缓冲值"></a>网卡缓冲值</h1><p>此处涉及到的缓冲有两个，一个为网卡的<strong>硬件缓冲</strong>，另一个是<strong>内核的缓冲</strong>。网卡驱动会采用硬中断的方式将接收到的数据从硬件缓冲copy到内核缓冲。</p>
<p>使用ethtool工具可以查看设置当前网卡缓冲值的大小。<code>ethtool -g eth0</code></p>
<p><img src="%5Cimages%5C20171217002.png" alt="查看网卡缓冲值大小"></p>
<p>图中上面的数值表示网卡支持的最大缓冲值，下面的表示目前设置的值。可以使用<code>ethtool -G eth0 rx 128</code></p>
<p>网上资料反馈设置缓冲值会导致网络down/up，瞬时网络中断。实际设置时，概率性出现网络中断。原因不明。</p>
<p>另外注意的是，改设置只是临时生效，每次系统重启时，会重新设置，最好的办法是将命令加入开机执行<code>rc.local</code>。</p>
<p>另另外：网卡缓冲值分为普通fifo buffer和ring buffer 环形缓冲，等学习之后再补充。</p>
]]></content>
      <tags>
        <tag>LINUX</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>H265码流格式</title>
    <url>/2018/02/04/H265_format/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>H265标准自2013年推出以来，一直受限于CPU或者GPU硬解性能的限制，难以普及。</p>
<p>IOS11的VideoToolbox支持硬解H265，开发者可以调用提供的接口实现HEVC的硬解。而安卓阵营近几代SOC芯片早就支持了H265的硬解，并且其计算能力也强大到出现了出现了讨论是否性能过剩的现象。至于PC端，由于PC设备更新速度远没有移动设备快速，目前在用的PC设备性能参差不齐，并且这类现象会持续一长段时间。</p>
<a id="more"></a>

<p>推流侧的H265比拉流要容易推广，主播向来持有的设备性能都较强，也是比较新的旗舰产品，一般都可以支持HEVC的硬编。</p>
<p>在CDN侧，各大CDN服务提供商大多数均已支持了H265格式的视频数据分发。</p>
<p>基于以上，预测2018年，各大视频内容提供商处于CDN带宽成本考虑，应该会把H265作为一个比较重要的工作项目。</p>
<p>所以，我们学习下H265的码流格式。</p>
<h1 id="FLV与H265"><a href="#FLV与H265" class="headerlink" title="FLV与H265"></a>FLV与H265</h1><p>FLV是一个Adobe公司为flash播放器(SWF)配套推出的视频封装格式。由于其格式结构简单，配套方案成熟，在流媒体行业内应用十分广泛。</p>
<p>虽然FLV的标准几乎每年都在更新，但是Adobe并没有让FLV支持H265。FLV支持的编码格式有以下几种（引自<a href="https://en.wikipedia.org/wiki/Flash_Video" target="_blank" rel="noopener">wikipedia</a>）：</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>Video encoding</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>RGB</td>
</tr>
<tr>
<td>1</td>
<td><a href="https://en.wikipedia.org/wiki/Run-length_encoding" target="_blank" rel="noopener">run-length</a></td>
</tr>
<tr>
<td>2</td>
<td><a href="https://en.wikipedia.org/wiki/Sorenson_codec" target="_blank" rel="noopener">Sorenson’s H.263</a></td>
</tr>
<tr>
<td>3</td>
<td>Screen 1</td>
</tr>
<tr>
<td>4</td>
<td>On2 TrueMotion <a href="https://en.wikipedia.org/wiki/VP6" target="_blank" rel="noopener">VP6</a></td>
</tr>
<tr>
<td>5</td>
<td><a href="https://en.wikipedia.org/wiki/VP6" target="_blank" rel="noopener">VP6</a> with alpha</td>
</tr>
<tr>
<td>6</td>
<td>Screen 2</td>
</tr>
<tr>
<td>7</td>
<td>MP4 <a href="https://en.wikipedia.org/wiki/H.264" target="_blank" rel="noopener">H.264</a></td>
</tr>
<tr>
<td>8</td>
<td>ITU <a href="https://en.wikipedia.org/wiki/H.263" target="_blank" rel="noopener">H.263</a></td>
</tr>
<tr>
<td>9</td>
<td><a href="https://en.wikipedia.org/wiki/MPEG-4_Part_2" target="_blank" rel="noopener">MPEG-4 ASP</a>.</td>
</tr>
</tbody></table>
<p>目前国内直播大多数采用HTTP-FLV的拉流方式，其原因是HTTP可以保证在TCP握手成功之后马上发起GET请求，不像RTMP那样还需要进行RTMP应用层面的握手以及各类message消息的传输来确定许多参数，从而保证较快的首屏时间。至于HLS，HDS，MSS，MPEG-DASH等基于切片的，在国外直播中较为常见，国内的直播普遍无法接受切片带来的延迟，因此HTTP-FLV在国内直播行业内应用广泛。</p>
<p>理所当然的，大家也都希望将H265的码流也封装进FLV中，如此可以省去很多适配工作。</p>
<p>因此，便有了非官方的墨守成规的”标准“了。</p>
<p>FLV中，Video Tag中的Tag Data中的第一字节的低四位表示编码格式CodecID，其取值便如上述表格所示，常见的是7，即AVC编码方式。而非官方的大家普遍的做法是将0XC=12D标志为HEVC。</p>
<p><img src="/images/20180204001.png" alt="CodecID"></p>
<h1 id="H265码流格式"><a href="#H265码流格式" class="headerlink" title="H265码流格式"></a>H265码流格式</h1><p>2018年2月6日补充，在非官方的FLV封装265码流中，基本与264一致，分为265标准自带的附录B（Annex-B）和avcC类似的hvcC。</p>
<h2 id="hvcC一般解析"><a href="#hvcC一般解析" class="headerlink" title="hvcC一般解析"></a>hvcC一般解析</h2><p><img src="/images/20180204002.png" alt="hvcC"></p>
<ol>
<li>2C<ol>
<li>2，代表非关键帧</li>
<li>CH=12D，代表CodecID=12D，为hevc</li>
</ol>
</li>
<li>01<ol>
<li>沿用AVC中的格式</li>
</ol>
</li>
<li>00 00 00<ol>
<li>沿用AVC中的格式</li>
</ol>
</li>
<li>00 00 15 B0<ol>
<li>代表下一个NALU的长度为15B0H=5552D字节</li>
</ol>
</li>
<li>02 01H=0000 0010 0000     0001B，NAL units header<ol>
<li>第一位，1比特，0，禁止位，forbidden_zero_bit。非零代表异常；</li>
<li>第二至七位，6比特，000001，NALU类型，nal_unit_type。<br>常见的类型有：<ol>
<li>40 01H–&gt;nal_unit_type=32D，VPS</li>
<li>42 01H–&gt;nal_unit_type=33D，SPS</li>
<li>44 01H–&gt;nal_unit_type=34D，PPS</li>
<li>4E 01H–&gt;nal_unit_type=39D，SEI</li>
<li>26 01H–&gt;nal_unit_type=19D，IDR</li>
<li>02 01H–&gt;nal_unit_type=1D，被参考的后置图像</li>
</ol>
</li>
</ol>
</li>
<li>第八至十三位，6比特，000000，nuh_layer_id，一般取值为0，非0为3D等特殊视频。</li>
<li>第十四至十六位，3比特，001，nuh_temporal_id_plus1，NALU所在时域层的标识号temporalId+1。</li>
</ol>
<h2 id="hvcC头解析"><a href="#hvcC头解析" class="headerlink" title="hvcC头解析"></a>hvcC头解析</h2><p><img src="/images/20180204003.png" alt="CodecID"></p>
<ol>
<li>1C<ol>
<li>1，代表关键帧</li>
<li>CH=12D，代表CodecID=12D，为hevc</li>
</ol>
</li>
<li>01<ol>
<li>沿用AVC中的格式</li>
</ol>
</li>
<li>00 00 00<ol>
<li>沿用AVC中的格式</li>
</ol>
</li>
<li>00 00 00 19<ol>
<li>下一个NALU的长度为19H字节</li>
</ol>
</li>
<li>40 01 0C 01 …<ol>
<li>40 01 : VPS</li>
</ol>
</li>
<li>00 00 00 28<ol>
<li>下一个NALU的长度为28H字节</li>
</ol>
</li>
<li>42 01 01 01 …<ol>
<li>42 01 : SPS</li>
</ol>
</li>
<li>00 00 00 08<ol>
<li>下一个NALU的长度为8H字节</li>
</ol>
</li>
<li>44 01 C1 71 …<ol>
<li>44 01 : PPS</li>
</ol>
</li>
<li>00 03 A0 C1<ol>
<li>下一个NALU的长度是03A0C1H字节</li>
</ol>
</li>
<li>26 01 ..<ol>
<li>26 01 : IDR</li>
</ol>
</li>
</ol>
<h2 id="Annex-B一般解析"><a href="#Annex-B一般解析" class="headerlink" title="Annex-B一般解析"></a>Annex-B一般解析</h2><p><img src="/images/20180204005.png" alt="CodecID"></p>
<ol>
<li>1C<ol>
<li>1，代表关键帧</li>
<li>CH=12D，代表CodecID=12D，为hevc</li>
</ol>
</li>
<li>01<ol>
<li>沿用AVC中的格式</li>
</ol>
</li>
<li>00 01 F4<ol>
<li>沿用AVC中的格式</li>
</ol>
</li>
<li>00 00 00 01<ol>
<li>Start code : 分隔符</li>
</ol>
</li>
<li>26 01 …<ol>
<li>26 01 : IDR</li>
</ol>
</li>
<li>00 00 03 00 …<ol>
<li>此处0x03即防竞争字节，emulation_prevention_three_byte</li>
</ol>
</li>
</ol>
<h2 id="Annex-B头解析"><a href="#Annex-B头解析" class="headerlink" title="Annex-B头解析"></a>Annex-B头解析</h2><p><img src="/images/20180204004.png" alt="CodecID"></p>
<ol>
<li>1C<ol>
<li>1，代表关键帧</li>
<li>CH=12D，代表CodecID=12D，为hevc</li>
</ol>
</li>
<li>01<ol>
<li>沿用AVC中的格式</li>
</ol>
</li>
<li>00 00 00<ol>
<li>沿用AVC中的格式</li>
</ol>
</li>
<li>00 00 00 01<ol>
<li>Start code : 分隔符</li>
</ol>
</li>
<li>40 01 …<ol>
<li>40 01 : VPS</li>
</ol>
</li>
<li>00 00 00 01<ol>
<li>Start code : 分隔符</li>
</ol>
</li>
<li>42 01 …<ol>
<li>42 01 : SPS</li>
</ol>
</li>
<li>00 00 00 01<ol>
<li>Start code : 分隔符</li>
</ol>
</li>
<li>44 01 …<ol>
<li>44 01 : PPS</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>live</tag>
        <tag>video_codec</tag>
      </tags>
  </entry>
  <entry>
    <title>自建个人NAS+HTPC</title>
    <url>/2018/07/24/NAS+HTPC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.intel.cn/content/www/cn/zh/products/processors/pentium/j5005.html" target="_blank" rel="noopener">英特尔® 奔腾® 银牌处理器 J5005</a>发布大半年了，作为10W TDP(设计散热功耗)中性能最强的CPU，在满足当前轻度使用的需求的同时，可以做到无风扇结构，即使24运行运行，也没有噪音（HDD机械噪声和电源风扇噪声另说），可以说是十分适合拿来做家庭服务器，NAS或者HTPC之类的来使用了。即使兼做桌面PC，不运行大型程序都是没有问题的。</p>
<p>该CPU自带UHD Graphics 605核显，频率800MHz，具备了目前大部分音视频的硬解加速。</p>
<p>一个月前偶然看到华擎终于出了款该CPU的主板了——<a href="http://www.asrock.cn/mb/Intel/J5005-ITX/index.cn.asp" target="_blank" rel="noopener">J5005-ITX</a>，J5005芯片直接焊死在主板上，并且自带了一个被动散热器。1000Mbps单网口，4个6Gbps的SATA3接口（个人存储的最佳盘位数），单个PCIE2.0插槽，提供一个HDMI2.0接口，支持4K*2K@60Hz的信号带宽。mini-ITX规格，攒mini机合适。</p>
<p>心动，种草。</p>
<p>自用的阿苏斯笔记本已经用了六七年了，也该换个其他的机器来做为非工作机使用了。准备看下其他配件，攒台自用小功率静音小机箱的家庭影音服务器。</p>
<a id="more"></a>

<h1 id="配置清单"><a href="#配置清单" class="headerlink" title="配置清单"></a>配置清单</h1><table>
<thead>
<tr>
<th>配件</th>
<th>型号</th>
<th>说明</th>
<th>价格</th>
</tr>
</thead>
<tbody><tr>
<td>主板</td>
<td>华擎J5005-ITX</td>
<td>如上文</td>
<td><a href="https://detail.tmall.com/item.htm?id=571645596079" target="_blank" rel="noopener">949</a></td>
</tr>
<tr>
<td>CPU</td>
<td>Intel奔腾银牌J5005</td>
<td>主板自带</td>
<td>-</td>
</tr>
<tr>
<td>内存</td>
<td>Kingston DDR4 2400 4G</td>
<td>SO-DIMM规格 笔记本内存</td>
<td><a href="https://item.jd.com/4071448.html" target="_blank" rel="noopener">359*2</a></td>
</tr>
<tr>
<td>固态硬盘</td>
<td>闪迪固态硬盘加强版120G</td>
<td>SATA3.0接口</td>
<td><a href="https://item.jd.com/1398976.html?dist=jd" target="_blank" rel="noopener">229</a></td>
</tr>
<tr>
<td>机械硬盘</td>
<td>西部数据WD30EZRZ</td>
<td>蓝盘 3TB SATA6Gb/s 64MB</td>
<td><a href="https://item.jd.com/2031262.html" target="_blank" rel="noopener">499*2</a></td>
</tr>
<tr>
<td>无线网卡</td>
<td>Intel 9260AC</td>
<td>1730Mbps 蓝牙5.0 2230规格</td>
<td><a href="https://item.taobao.com/item.htm?id=525364173069" target="_blank" rel="noopener">97</a></td>
</tr>
<tr>
<td>机箱</td>
<td>迎广MS04</td>
<td>贵</td>
<td><a href="https://item.taobao.com/item.htm?id=555056409465" target="_blank" rel="noopener">880</a></td>
</tr>
<tr>
<td>电源</td>
<td>powerman 265w</td>
<td>80plus铜牌 机箱自带</td>
<td>-</td>
</tr>
</tbody></table>
<p>总计3900左右，主要还是机箱和内存贵。</p>
<p>未完待续。。。</p>
]]></content>
      <tags>
        <tag>NAS</tag>
        <tag>HTPC</tag>
        <tag>openmediavalut</tag>
        <tag>docker</tag>
        <tag>hexo</tag>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>FFmpeg测试序列</title>
    <url>/2018/01/01/ffmpeg-test-stream/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>经常需要做测试以及功能验证，每次都要找个视频文件或者线上拉一路流推流。在某些测试场景下，视频文件和线上的流都存在一定的码率波动，对于实际的测试数据有一定的影响。所以需要一路码率、帧率、GOP等参数可调且尽可能标准的测试流，并且使用方式要尽可能的简答，适用大多数的场景。</p>
<p>一般机器都安装<code>FFmpeg</code>，所以打算用<code>FFmpeg</code>实现测试流的生成。查阅资料发现<code>FFmpeg</code>的<code>lavfi</code>自带简单的测试视频，利用<code>ffmpeg</code>本身的一堆编码参数便可以得到想要的标准测试流。</p>
<a id="more"></a>

<h1 id="FFmpeg安装"><a href="#FFmpeg安装" class="headerlink" title="FFmpeg安装"></a>FFmpeg安装</h1><p><code>FFmpeg</code>的安装，参考官网的指南足矣。其他的安装指南写得再好，还是没有官方的好，而且附带中文版，集成了几乎平时用到的所有lib。</p>
<p><a href="https://trac.ffmpeg.org/wiki/CompilationGuide/Centos" target="_blank" rel="noopener">CentOS安装FFmpeg指南</a></p>
<p>我在一台VPS上安装<code>X265</code>库的时候出了个问题：</p>
<p><img src="/images/20180101001.png" alt="X265 make error"></p>
<p>我通过以下操作解决：</p>
<p>卸载<code>yum</code>原本的<code>yasm</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum remove yasm</span><br></pre></td></tr></table></figure>

<p>将按照官方指南中安装的高版本的<code>yasm</code>链接到<code>PATH</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /root/bin/yasm/usr/bin/yasm</span><br></pre></td></tr></table></figure>

<p>安装完毕</p>
<p><img src="/images/20180101002.png" alt="FFmpeg"></p>
<h1 id="测试流生成"><a href="#测试流生成" class="headerlink" title="测试流生成"></a>测试流生成</h1><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>利用lavfi生成测试视频，查到以下说明，按图索骥即可生成测试图像。</p>
<p><a href="http://www.bogotobogo.com/FFMpeg/ffmpeg_video_test_patterns_src.php" target="_blank" rel="noopener">http://www.bogotobogo.com/FFMpeg/ffmpeg_video_test_patterns_src.php</a></p>
<p>此处我采用的参数如下，使用testsrc这个图像，很有小时候周二下午的回忆。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-f lavfi -i <span class="string">"testsrc=size=1920x1080:rate=30:duration=5"</span></span><br></pre></td></tr></table></figure>

<p>参数含义：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>testsrc</code></td>
<td>使用<code>testsrc</code>作为测试画面</td>
</tr>
<tr>
<td><code>size</code></td>
<td>分辨率</td>
</tr>
<tr>
<td><code>rate</code></td>
<td>帧率</td>
</tr>
<tr>
<td><code>duration</code></td>
<td>持续时间</td>
</tr>
</tbody></table>
<h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><p>测试音频采用sine正弦波。可条件频率，采样率等参数。具体参考官网说明</p>
<p><a href="https://lists.ffmpeg.org/pipermail/ffmpeg-cvslog/2013-March/062382.html" target="_blank" rel="noopener">https://lists.ffmpeg.org/pipermail/ffmpeg-cvslog/2013-March/062382.html</a></p>
<p>此处我采用的参数是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-f lavfi -i <span class="string">"sine=frequency=440:sample_rate=44100:beep_factor=4:duration=5"</span></span><br></pre></td></tr></table></figure>

<p>参数含义：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>sine</code></td>
<td>使用正弦波信号作为输入</td>
</tr>
<tr>
<td><code>frequency</code></td>
<td>正弦波频率</td>
</tr>
<tr>
<td><code>sample_rate</code></td>
<td>音频采样率</td>
</tr>
<tr>
<td><code>beep_factor</code></td>
<td>每秒产生一个蜂鸣，蜂鸣频率为正弦波频率的四倍</td>
</tr>
<tr>
<td><code>duration</code></td>
<td>持续时间</td>
</tr>
</tbody></table>
<h2 id="合成测试流"><a href="#合成测试流" class="headerlink" title="合成测试流"></a>合成测试流</h2><p>将以上视频和音频作为<code>FFmpeg</code>的输入，通过ffmpeg自带的一些编码参数和码率控制参数输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -f lavfi -i testsrc=duration=5:size=1920x1080:rate=300 \</span><br><span class="line">	-f lavfi -i sine=frequency=440:sample_rate=44100:beep_factor=4:duration=5 \</span><br><span class="line">	-acodec libfdk_aac \</span><br><span class="line">	-vcodec libx264  -bf 0 -b:a 100k  -b:v 1900k -bufsize 1000k \</span><br><span class="line">	-r 30 -g 30 -sc_threshold 0 \</span><br><span class="line">	-profile baseline -pix_fmt yuv420p \</span><br><span class="line">	-f flv test.flv</span><br></pre></td></tr></table></figure>

<p>输出画面如下：</p>
<p><img src="/images/20180101003.png" alt="test stream"></p>
<p>观察生成的<code>test.flv</code>，发生其码率并不是指定的音频100kbps，视频1900kbps，而是只有730kbps。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ffmpeg -i test.flv </span></span><br><span class="line">...</span><br><span class="line">Input <span class="comment">#0, flv, from 'test.flv':</span></span><br><span class="line">  Metadata:</span><br><span class="line">    encoder         : Lavf58.3.100</span><br><span class="line">  Duration: 00:00:05.08, start: 0.000000, bitrate: 730 kb/s</span><br><span class="line">    Stream <span class="comment">#0:0: Video: h264 (Constrained Baseline), yuv420p(progressive), 1920x1080 [SAR 1:1 DAR 16:9], 1900 kb/s, 30 fps, 30 tbr, 1k tbn, 60 tbc</span></span><br><span class="line">    Stream <span class="comment">#0:1: Audio: aac (LC), 44100 Hz, mono, fltp, 100 kb/s</span></span><br></pre></td></tr></table></figure>

<p>无论如何修改指定的码率的值，输出码率总是明显小于指定值。</p>
<p>查阅资料后，使用<code>x264</code>的参数，启用CBR模式，解决问题，码率稳定在2000kbps左右：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -f lavfi -i testsrc=duration=5:size=1920x1080:rate=30 \</span><br><span class="line">	-f lavfi -i sine=frequency=440:sample_rate=44100:beep_factor=4:duration=5 \</span><br><span class="line">	-acodec libfdk_aac -b:a 100k \</span><br><span class="line">	-vcodec libx264 -x264opts bitrate=1900:vbv-maxrate=1900:vbv-bufsize=1000:nal_hrd=cbr \</span><br><span class="line">	-r 30 -g 30 -sc_threshold 0 \</span><br><span class="line">	-profile baseline -pix_fmt yuv420p \</span><br><span class="line">	-f flv test.flv</span><br></pre></td></tr></table></figure>
<p>以上<code>FFmpeg</code>参数含义：</p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>-acodec libfdk_aac</code></td>
<td>指定音频编码为<code>aac</code>格式</td>
</tr>
<tr>
<td><code>-b:a 100k</code></td>
<td>指定音频编码输出码率为100kbps</td>
</tr>
<tr>
<td><code>-vcodec libx264</code></td>
<td>指定视频编码为<code>h264</code>格式</td>
</tr>
<tr>
<td><code>-x264opts</code></td>
<td>启用<code>x264</code>参数</td>
</tr>
<tr>
<td><code>-x264opts bitrate=1900</code></td>
<td><code>x264</code>参数：指定视频输出码率为1900kbps</td>
</tr>
<tr>
<td><code>-x264opts vbv-maxrate=1900</code></td>
<td><code>x264</code>参数：指定视频输出的最高码率为1900kbps</td>
</tr>
<tr>
<td><code>-x264opts vbv-bufsize=1000</code></td>
<td><code>x264</code>参数：指定视频编码的buffer为1000kb</td>
</tr>
<tr>
<td><code>-x264opts nal_hrd=cbr</code></td>
<td><code>x264</code>参数：设置HRD为CBR，严格按照指定码率转码</td>
</tr>
<tr>
<td><code>-r 30</code></td>
<td>指定输出帧率为30fps</td>
</tr>
<tr>
<td><code>-g 30</code></td>
<td>指定输出视频<code>GOP</code>为30帧</td>
</tr>
<tr>
<td><code>-sc_threshold 0</code></td>
<td>视频编码关闭 <code>scenecut</code>模式，用以不再自动生成I帧</td>
</tr>
<tr>
<td><code>-profile baseline</code></td>
<td>指定视频编码规则为<code>baseline</code></td>
</tr>
<tr>
<td><code>-pix_fmt yuv420p</code></td>
<td>指定输出数据格式为<code>yuv420p</code>，<code>baseline</code>只支持这种</td>
</tr>
<tr>
<td><code>-f flv</code></td>
<td>指定输出封装为<code>flv</code>格式</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ffmpeg -i test1.flv </span></span><br><span class="line">...</span><br><span class="line">Input <span class="comment">#0, flv, from 'test1.flv':</span></span><br><span class="line">  Metadata:</span><br><span class="line">    encoder         : Lavf58.3.100</span><br><span class="line">  Duration: 00:00:05.05, start: 0.000000, bitrate: 1975 kb/s</span><br><span class="line">    Stream <span class="comment">#0:0: Video: h264 (Constrained Baseline), yuv420p(progressive), 1920x1080 [SAR 1:1 DAR 16:9], 1900 kb/s, 30 fps, 30 tbr, 1k tbn, 60 tbc</span></span><br><span class="line">    Stream <span class="comment">#0:1: Audio: aac (LC), 44100 Hz, mono, fltp, 100 kb/s</span></span><br><span class="line">At least one output file must be specified</span><br></pre></td></tr></table></figure>

<p><img src="/images/20180101004.png" alt="2000kbps stream"></p>
<p>此处观察<code>FFmpeg</code>打印的日志发现，两次转码只在<code>x264</code>的参数上差了一个指标，如下两图，下图指定了<code>nal_hrd=cbr</code>。</p>
<p><img src="/images/20180101005.png" alt="nal_hrd=none"></p>
<p><img src="/images/20180101006.png" alt="nal_hrd=cbr"></p>
<p>那么这个<code>nal_hrd=cbr</code>又是什么鬼呢？</p>
<h2 id="HRD？没搞明白"><a href="#HRD？没搞明白" class="headerlink" title="HRD？没搞明白"></a>HRD？没搞明白</h2><p>上述两者的唯一区别便是nal_hrd是否有设置成CBR，CBR(Constant Bitrate, 常数比特率 ) ABR(Average Bitrate)<br>VBR(Variable Bitrate)只是x264按下不表。并没有查到相关资料，没有搞明白这些跟HRD有啥关系。</p>
<p>假想码流调度器(hypothetical reference decoder, HRD)，<a href="https://en.wikipedia.org/wiki/Video_buffering_verifier" target="_blank" rel="noopener">wiki</a>上说在264标准中，HRD已经被VBV代替了，也就是设置的<code>vbv-maxrate</code>和<code>vbv-bufsize</code>两个参数。不清楚为什么还需要设置HRD为CBR模式。</p>
<p>关于VBV中<code>vbv-maxrate</code>和<code>vbv-bufsize</code>两个参数的关系，这个文章中有所解释：<a href="http://www.bretl.com/mpeghtml/VBV.HTM" target="_blank" rel="noopener">http://www.bretl.com/mpeghtml/VBV.HTM</a></p>
<h1 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ffmpeg -re -f lavfi -i testsrc=duration=5:size=1920x1080:rate=30 \</span><br><span class="line">	-re -f lavfi -i sine=frequency=440:sample_rate=44100:beep_factor=4:duration=5 \</span><br><span class="line">	-acodec libfdk_aac -b:a 100k \</span><br><span class="line">	-vcodec libx264 -x264opts bitrate=1900:vbv-maxrate=1900:vbv-bufsize=1000:nal_hrd=cbr \</span><br><span class="line">	-r 30 -g 30 -sc_threshold 0 \</span><br><span class="line">	-profile baseline -pix_fmt yuv420p \</span><br><span class="line">	-f flv rtmp://127.0.0.1:1935/xujk.test.com/live/stream</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>live</tag>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>grep awk匹配字符串性能对比</title>
    <url>/2017/08/20/grep-awk-matching-performance/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近期遇到个场景，需要在某个较大的文本中匹配特定的一批字符串，并将其滤除或者打印出来。</p>
<p>使用了shell的<code>grep</code>和<code>awk</code>，对于这两个工具的文本处理效率和方法有了些基本的认识。</p>
<a id="more"></a>

<h1 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h1><p>最初的想法是<code>grep</code>命令，即：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -Ff A B	<span class="comment">#打印文件A和文件B中有相同字符串的行</span></span><br><span class="line">grep -vFf A B	<span class="comment">#打印文件B中有，但是文件A中没有的行</span></span><br></pre></td></tr></table></figure>

<p>由于待处理的文件有百万甚至千万行，直接<code>grep</code>导致将内存爆炸。测试使用的2G内存VPS直接进程killed，而使用了32G内存的物理机，在运行一段时间后，直接宕机。ミﾟДﾟ彡</p>
<h1 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h1><p>后续使用了awk中的匹配功能，整体内存使用在1G左右，效率也高很多。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">'ARGIND==1 &#123;a[$0]&#125; ARGIND&gt;1&amp;&amp;($3 in a) &#123;print $0&#125;'</span> A B</span><br><span class="line"><span class="comment">#ARGIND表示当前文件序号</span></span><br><span class="line"><span class="comment">#将A文件的$0赋值到数组a，如果B文件某行的$3有在数组a中出现，则打印该行；</span></span><br><span class="line">awk <span class="string">'ARGIND==1 &#123;a[$0]&#125; ARGIND&gt;1&amp;&amp;!($3 in a) &#123;print $0&#125;'</span> A B</span><br><span class="line"><span class="comment">#将A文件的$0赋值到数组a，如果B文件某行的$3没有在数组a中出现，则打印该行；</span></span><br></pre></td></tr></table></figure>



<p>如此这般，awk的文本处理效率确实很高，使用方法十分灵活。好好学习这个吧~</p>
]]></content>
      <tags>
        <tag>LINUX</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2016/10/30/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo安装与设置</title>
    <url>/2017/08/26/hexo-setup-and-config/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>此篇简单介绍hexo和主题的安装，以及一个配置项。</p>
<a id="more"></a>

<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>安装Git和node.js后，打开gitbash</p>
<p> npm install -g hexo-cli</p>
<p>一些必要的插件将会自动依赖安装，不需要另行安装。</p>
<p>初始化hexo</p>
 <figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">hexo init "C:\Users\jingkaixu\OneDrive\GitHub"</span><br></pre></td></tr></table></figure>

<p>会有几个warning，不影响最终的安装结果。此时hexo已完成安装。初步可以使用。</p>
<h1 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h1><p>下载喜欢的主题，并配置启用。配置参考主题提供方所给文档。此处采用比较流行的NexT主题。</p>
<p>主题配置文件注意每个配置项的：之后要有个空格，否则会报错。</p>
<p> NexT安装可以参考其官方文档，不再赘述。<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT</a></p>
<h1 id="上传方式配置"><a href="#上传方式配置" class="headerlink" title="上传方式配置"></a>上传方式配置</h1><p>deploy方法，由于使用了github的page服务，所以选择ssh deploy。</p>
<p>在本地生成ssh指纹后，添加到github的deploy keys中。 </p>
<p>具体可以参考<a href="https://jingyan.baidu.com/article/d8072ac47aca0fec95cefd2d.html" target="_blank" rel="noopener">这条百度经验</a>。</p>
<h1 id="设置apple-touch-icon"><a href="#设置apple-touch-icon" class="headerlink" title="设置apple-touch-icon"></a>设置apple-touch-icon</h1><p>Safari浏览器收藏的时候，不会采用favicon.ico最为默认图标，而是有个apple-touch-icon作为图标，可以参考<a href="https://developer.apple.com/library/content/documentation/AppleApplications/Reference/SafariWebContent/ConfiguringWebApplications/ConfiguringWebApplications.html" target="_blank" rel="noopener">苹果官方文档</a>，此时需要在主题目录中修改<code>\themes\next\layout\_custom\header.swig</code>文件，在其中新增一个<code>&lt;linkrel=&quot;apple-touch-icon&quot; href=&quot;apple-touch-icon.png&quot;/&gt;</code>，如此再生成静态文件时，会自动加入这一行代码。再在source目录中加入信号的apple-touch-icon.png即可。</p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown_Test</title>
    <url>/2016/11/12/markdown_test/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>This a MarkDown test script. there are syntax code blow its markup effects. </p>
<a id="more"></a>  

<hr>
<p>[TOC]</p>
<h1 id="HEADER"><a href="#HEADER" class="headerlink" title="HEADER:"></a>HEADER:</h1><h1 id="HEADER-1"><a href="#HEADER-1" class="headerlink" title="HEADER_1"></a>HEADER_1</h1><p><code># HEADER_1 #</code></p>
<h2 id="HEADER-2"><a href="#HEADER-2" class="headerlink" title="HEADER_2"></a>HEADER_2</h2><p><code>##  HEADER_2 ##</code></p>
<h3 id="HEADER-3"><a href="#HEADER-3" class="headerlink" title="HEADER_3"></a>HEADER_3</h3><p><code>###  HEADER_3 ###</code></p>
<h4 id="HEADER-4"><a href="#HEADER-4" class="headerlink" title="HEADER_4"></a>HEADER_4</h4><p><code>#### HEADER_4 ####</code></p>
<h1 id="LIST"><a href="#LIST" class="headerlink" title="LIST:"></a>LIST:</h1><h2 id="有序："><a href="#有序：" class="headerlink" title="有序："></a>有序：</h2><pre><code>1. a
    1. aa
    2. bb
        1. aaa
        2. aaa
    3. cc
2. b
3. c  </code></pre><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>a  </span><br><span class="line"><span class="bullet">2. </span>b  </span><br><span class="line"><span class="bullet">3. </span>c</span><br></pre></td></tr></table></figure>
<h2 id="无序："><a href="#无序：" class="headerlink" title="无序："></a>无序：</h2><ul>
<li>a<ul>
<li>a.a<ul>
<li>a.a.a<ul>
<li>a.a.a.a</li>
<li>a.a.a.b</li>
</ul>
</li>
<li>a.a.b</li>
</ul>
</li>
<li>a.b</li>
</ul>
</li>
<li>b  </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- a  </span><br><span class="line">	- a.a  </span><br><span class="line">		* a.a.a  </span><br><span class="line">			+ a.a.a.a  </span><br><span class="line">			- a.a.a.b  </span><br><span class="line">		- a.a.b  </span><br><span class="line">	- a.b  </span><br><span class="line">- b</span><br></pre></td></tr></table></figure>
<p><strong>note</strong>: ‘<code>*</code>‘ is equivalent to ‘<code>-</code>‘ &amp; ‘<code>+</code>‘. </p>
<h1 id="QUOTE"><a href="#QUOTE" class="headerlink" title="QUOTE:"></a>QUOTE:</h1><blockquote>
<p>Ygritte: you know nothing，Jon Snow.  </p>
</blockquote>
<pre><code>&gt; Ygritte: you know nothing，Jon Snow.   </code></pre><h1 id="CODE"><a href="#CODE" class="headerlink" title="CODE:"></a>CODE:</h1><h2 id="in-a-sentence："><a href="#in-a-sentence：" class="headerlink" title="in a sentence："></a>in a sentence：</h2><p><code>var</code> is a variable.  </p>
<pre><code>`var` is a variable.  </code></pre><h2 id="code-block："><a href="#code-block：" class="headerlink" title="code block："></a>code block：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> context = canvas.getContext(<span class="string">"2d"</span>);</span><br></pre></td></tr></table></figure>


<p><code>```javascript var context = canvas.getContext(&quot;2d&quot;);```</code>   </p>
<h1 id="TABLE"><a href="#TABLE" class="headerlink" title="TABLE:"></a>TABLE:</h1><table>
<thead>
<tr>
<th>Tables</th>
<th align="center">Are</th>
<th align="right">Cool</th>
</tr>
</thead>
<tbody><tr>
<td>col 3 is</td>
<td align="center">right-aligned</td>
<td align="right">$1600</td>
</tr>
<tr>
<td>col 2 is</td>
<td align="center">centered</td>
<td align="right">$12</td>
</tr>
<tr>
<td>zebra stripes</td>
<td align="center">are neat</td>
<td align="right">$1</td>
</tr>
</tbody></table>
<pre><code>| Tables        | Are           | Cool  |  
| ------------- |:-------------:| -----:|  
| col 3 is      | right-aligned | $1600 |  
| col 2 is      | centered      |   $12 |  
| zebra stripes | are neat      |    $1 |  </code></pre><h1 id="FORMAT"><a href="#FORMAT" class="headerlink" title="FORMAT:"></a>FORMAT:</h1><h2 id="LETTER-FORMAT"><a href="#LETTER-FORMAT" class="headerlink" title="LETTER FORMAT:"></a>LETTER FORMAT:</h2><p>this is <strong>bold</strong>, and this is <em>italic</em>, this is <del>delete-line</del>.<br>    <code>this is **bold**, and this is *italic*, this is ~~delete-line~~.</code>  </p>
<h2 id="HORIZONTAL-LINE"><a href="#HORIZONTAL-LINE" class="headerlink" title="HORIZONTAL LINE:"></a>HORIZONTAL LINE:</h2><hr>
<hr>
<pre><code>---
***</code></pre><h1 id="TODO-or-ORDER-LIST"><a href="#TODO-or-ORDER-LIST" class="headerlink" title="TODO or ORDER LIST:"></a>TODO or ORDER LIST:</h1><ul>
<li><input disabled="" type="checkbox"> <strong>Cmd Markdown 开发</strong><ul>
<li><input disabled="" type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li><input disabled="" type="checkbox"> 支持以 PDF 格式导出文稿</li>
<li><input checked="" disabled="" type="checkbox"> 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="noopener">语法参考</a></li>
<li><input checked="" disabled="" type="checkbox"> 改进 LaTex 功能<ul>
<li><input checked="" disabled="" type="checkbox"> 修复 LaTex 公式渲染问题</li>
<li><input checked="" disabled="" type="checkbox"> 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers" target="_blank" rel="noopener">语法参考</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled="" type="checkbox"> <strong>七月旅行准备</strong><ul>
<li><input disabled="" type="checkbox"> 准备邮轮上需要携带的物品</li>
<li><input disabled="" type="checkbox"> 浏览日本免税店的物品</li>
<li><input checked="" disabled="" type="checkbox"> 购买蓝宝石公主号七月一日的船票</li>
</ul>
</li>
</ul>
<pre><code>- [ ] **Cmd Markdown 开发**
    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率
    - [ ] 支持以 PDF 格式导出文稿
    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)
    - [x] 改进 LaTex 功能
        - [x] 修复 LaTex 公式渲染问题
        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)
- [ ] **七月旅行准备**
    - [ ] 准备邮轮上需要携带的物品
    - [ ] 浏览日本免税店的物品
    - [x] 购买蓝宝石公主号七月一日的船票</code></pre><h1 id="HYPERLINK"><a href="#HYPERLINK" class="headerlink" title="HYPERLINK:"></a>HYPERLINK:</h1><p>this is <a href="https://www.bing.com/" target="_blank" rel="noopener">bing</a>.<br>    <code>this is [bing](https://www.bing.com/).</code></p>
<h1 id="IMAGE"><a href="#IMAGE" class="headerlink" title="IMAGE:"></a>IMAGE:</h1><p>this is the <a href="https://www.douban.com/" target="_blank" rel="noopener"><em>douban</em></a> icon.<br><img src="https://img3.doubanio.com/pics/douban-icons/favicon_48x48.png" alt="Alt text"><br>    <code>![Alt text](https://img3.doubanio.com/pics/douban-icons/favicon_48x48.png &quot;douban icon&quot;)</code> </p>
<h1 id="others"><a href="#others" class="headerlink" title="others:"></a>others:</h1><p>it seems that <a href="https://hexo.io/" target="_blank" rel="noopener">HEXO</a> does not support some MarkDown syntax,  like flow-graph and sequence-graph. of course there are lots of features need to search.<br>お互い顽张ろう</p>
<p>​    </p>
<p>​    </p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>十一月的一些小想法（二）</title>
    <url>/2017/11/19/meander-in-November-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>书接上回。</p>
<p>今天讲下最近关于电影和音乐的一些想法。</p>
<h1 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h1><p>看电影比看书是勤快多了。人呐，总是爱挑简单的事做，懒胚。</p>
<p>院线档期的大片和其他一些网上的盗版电影倒是都看了不少，大概以下几部让人印象很是深刻：</p>
<a id="more"></a>

<h2 id="降临"><a href="#降临" class="headerlink" title="降临"></a>降临</h2><p> <a href="https://movie.douban.com/subject/21324900/" target="_blank" rel="noopener">《降临》</a>是今年年初在大陆上映的一部科幻片。上映时，霸屏朋友圈蛮久的，被很多人称为硬科幻。当时没有去电影院支持，现在只能下载盗版BT了。</p>
<p>故事还是比较简单的，地球突然出现一批外星文明的飞船，身为人类语言学家的女主和身为物理学（还是数学）家的男主一起进入飞船试图与外星人交流。最终女主在和外星人的接触过程中逐渐学会了外星文字。而外星文字跳出时间的限制知晓未来与过去。女主因此预见到了未来：和男主结合，育有一女，女儿后来得不治之症死亡，男主无法接受离去。</p>
<p>其实这片并不算纯粹的科幻片，应该算是科幻片与文艺片的结合，影片更多的探讨了一些哲学的概念，关于时间，人类发展，未来。</p>
<p>片子中外星人使用的文字倒是很神奇，跟中国的水墨画十分相似，其中的意思包含在不同的晕染之中（是不是想说我们中国才能拯救世界，啊哈哈哈）。</p>
<p>豆瓣有一篇脑洞很大的影评，<a href="https://movie.douban.com/review/8307050/" target="_blank" rel="noopener">你不知道的《降临》背后的恐怖真相</a>，闲暇时可以读读。作者意淫了一把大的，认为外星文字就是中文的演变，确实是牛逼的中文呀。</p>
<p>片尾有个有趣的情节是，女主通过外星文字知道了自己的未来：她会和男主会在一起，所生的女儿会因为怪病而死去，男主因此而离去。但是最后，得知了一切未来的女主还是深情的望着男主，与他拥抱在一起。这种明知前途荆棘丛生，依然无畏前行的勇气估计也是人类可以生存至今的原因吧。</p>
<h2 id="超体"><a href="#超体" class="headerlink" title="超体"></a>超体</h2><p><a href="https://movie.douban.com/subject/24404677/" target="_blank" rel="noopener">《超体》</a>讲述了女主意外吸收了超大量的人类胚胎时期的原始物质CH后，大脑使用率逐渐达到100%的故事。随着人脑利用率的提升，女主开始可以控制自己的身体，控制身边的物质，最后和时间空间融为一体。</p>
<p>本来只是像看下Scarlett Johansson的脸（顺便吐槽Scarlett的身材确实不咋地呀，不晓得为什么你们都这么爱她），想不到这电影倒是和同样是Scarlett“主演”的<a href="https://movie.douban.com/subject/6722879/" target="_blank" rel="noopener">《她》</a>一样惊艳到我了。片中对于人类起源，发展与未来的思考，这一套很是我的菜。</p>
<p>我本身还是蛮拜服中国古代那一套哲学理论的。古人认为的天地之间的规律与秩序是“道”，《老子》中所述的“<strong>道生一，一生二，二生三，三生万物</strong>”，所讲述的是人是道的转换而成的一种产物，而人又要追求道，希冀得“道”。</p>
<p>超体电影中，女主角意外得以快速进化，以至于可以控制身边的物质，最后超脱时间和空间，化入其中。而影片中一直出现的画面是人类的起源，生命的起源，从一片无机物质中孕育出细胞和生命。两边一对比，似乎我们追求的极致便是虚无，而我们又是从虚无中而来。这与中国古代的世界观体系，万物孕于道，而人又求道有点类似。</p>
<p>导演吕克·贝松或许只是像表述他所理解的未来，他所理解的人们所追求的终极目标的样子。而每个观众所体会到的或许又是另外的样子。</p>
<h2 id="浪潮"><a href="#浪潮" class="headerlink" title="浪潮"></a>浪潮</h2><p> <a href="https://movie.douban.com/subject/2297265/" target="_blank" rel="noopener">《浪潮》</a>，据说是根据实际事件改编，讲述了一位德国教师，在教授独裁政治课程时，为了让学生们对独裁统治有更形象的认识，在课堂上模拟了独裁统治的一些方式，包括发言要起立，上下课有仪式，称呼老师特定称谓等。后来愈发不可收拾，有了统一服饰，统一口号，统一的logo，最终大部分学生有了统一的思想形态，统一的行动，酿成大祸。</p>
<p>影片本身要说的应该是独裁统治很容易重演，希望保持警惕这样吧。但是身为一个在中国成长的人来说，这不就是我们的小学，初中，高中，甚至大学嘛。我们不是一直被要求穿校服，上课遵守纪律，喊统一口号嘛。记得小时候老师经常说的也是不要搞特殊，每个人不管在家如何，在学校大家都要一样，这样想想，好可怕，可怕，可怕。</p>
<h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><p>今日打算弃坑网易云音乐了，看着歌单里一批一批变灰，实在是难受得很。可惜还有十个月的会员呢。</p>
<p>所以说这种网络音乐提供商跟音乐版权公司签什么独家版权实在是不友好得很，不仅不利于行业内竞争，也让消费者少了很多选择项嘛。搞个会员机制，或者其他收费方式都是很不错的嘛。唉~</p>
<p>吐槽完了，谈下最近几首歌。</p>
<h2 id="现象七十二变"><a href="#现象七十二变" class="headerlink" title="现象七十二变"></a>现象七十二变</h2><p>罗大佑的这首歌实在是太妙。歌词开头就让我眼前一亮。</p>
<blockquote>
<p>黄花岗有七十二个烈士</p>
<p>孔老夫子有七十二个弟子</p>
<p>孙悟空的魔法七十二变</p>
<p>我们又等到民国七十二年</p>
<p>……</p>
</blockquote>
<p>虽然粗看不就是四个七十二嘛，但是细想，时空交错，虚实不定，开头就特殊得很。</p>
<p>歌词讽刺了很多现今的虚假现象，人们道貌岸然，私下里却各种小心思。罗大佑被一些人称为中国的Bob Dylan，也不是没有原因。</p>
<p>高晓松在《晓说》里经常说中国人写词的水平天下无敌，谱曲的水平确实实在一般般。本人实在是没啥音乐天赋，听了几首流行音乐，对于曲谱得怎么样，实在赏析不来，不过歌词赏析的能力，想来中国人应该都是可以谈下的。</p>
<p>罗大佑的很多音乐的歌词在他那个鸭般的奇怪嗓音唱出来确实让人眼前一亮。《将进酒》，《鹿港小镇》，《之乎者也》都是写可以单曲循环几十遍的佳作。也不在此装逼的分析，这种东西自己爱听就好。</p>
<h2 id="胡德夫"><a href="#胡德夫" class="headerlink" title="胡德夫"></a>胡德夫</h2><p>学生的时候，在广播里听到胡德夫的《匆匆》，这位大爷的独特唱腔让人神清气爽，似乎放下了一切，坐在海边吹风般舒畅。这个广播节目现在还记得呢，浙江之声的《方雨大搜索》，虽然独在异乡，有时候也听下故乡的电台。</p>
<p>胡德夫最近应该很多人都知道了吧，看到豆瓣有他的节目，上了首页。他的音乐基本就他的自弹钢琴，一口嗓子，无它。唱腔很独特，不知道怎么形容，经常会混入台湾原住民的一些独特的方言的发音，一些简单的”啊“， ”哈“， ”哦“之类的。我这个农村进城务工人员，常年待在城市里，只听到普通话的，他的音乐确实很适合在浮躁时，放空一切，安静发呆。</p>
<p>胡德夫有很多经典的音乐，《匆匆》，《太平洋的风》，《牛背上的小孩》，我最喜欢的是他翻唱的Leonard Cohen的《hallelujah》，我不知道这是不是算是一首上帝颂歌，不过我听来确实净化心灵之歌。相对Cohen，胡德夫更为纯粹，如果是在赞颂上帝来看，也更为纯洁些吧。</p>
<p>点击下面可以尝试下~拜谢。</p>

        <div id="aplayer-DghJxpip" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content"></pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-DghJxpip"),
            narrow: false,
            autoplay: false,
            showlrc: false,
            music: {
              title: "hallelujah",
              author: "胡德夫",
              url: "/music/胡德夫-Hallelujah.mp3",
              pic: "/music/胡德夫-Hallelujah.jpg",
              lrc: ""
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>

<h2 id="体育"><a href="#体育" class="headerlink" title="体育"></a>体育</h2><p>其实并不是谈体育，我这羸弱的身体，从小就没对哪项体育活动感兴趣过。只是讲了读书，电影，音乐之类的东西之后，打算讲下身体的，不过感觉标题为体育比较和谐。标题党！标题党！！标题党！！！实在是可恶。</p>
<p>好了，讲下身体吧。</p>
<p>唉，我这<strong>羸弱的身体</strong>，体力不行就算了，工作一年，游泳圈出来了也就算了，居然有了脂肪肝，还是轻-中度脂肪肝。简直恶搞，简直恶搞，简直恶搞。</p>
<p>体检B超的那个姑娘，你知道你淡淡的那句“有点脂肪肝”对我有多大伤害嘛。(╯︵╰)</p>
<p>手机上装了个keep，装了个囚徒健身，装了个薄荷，你说说，有啥用，有啥用，有啥用。</p>
<p>哎，不写了，去做个十个仰卧起坐吧。</p>
<p><strong>最后福利时间，传授个小技巧，与诸君共勉：</strong></p>
<p><img src="/images/2017111901.jpg" alt="福利时间"></p>
]]></content>
      <tags>
        <tag>痴人说梦</tag>
      </tags>
  </entry>
  <entry>
    <title>十一月的一些小想法（一）</title>
    <url>/2017/11/18/meander-in-November-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>17年的光棍节过了，有种还停留在<strong>世纪大光棍节</strong>的那天的错觉。</p>
<p>工作一年多，对于“脱光”早已不在期待，神奇的是对于抢购也不再热情，看来促销力度还不够呀。</p>
<p>这样，把脑袋里的小想法记录下来，语言组织能力薄弱得很，权当<strong>练习下打字水平</strong>吧。</p>
<h1 id="光棍节"><a href="#光棍节" class="headerlink" title="光棍节"></a>光棍节</h1><p>所有的节日不外乎两类：纪念很有地位或者知名度的人物或者事件，纪念地位太低或者遭遇凄惨的人物或者事件。</p>
<p>光棍节显然属于后者。从字面本身看就对我们汪类有着深深的恶意。</p>
<a id="more"></a>

<h2 id="购物"><a href="#购物" class="headerlink" title="购物"></a>购物</h2><p>虽然没买什么，但其实还是想买的。想买个kindle装逼。想买个最贵的kindle装逼。想买个美版的带3G上网功能的最贵的kindle oasis装逼。</p>
<p><strong>没钱！！！买不起，太贵了。</strong></p>
<h2 id="光棍"><a href="#光棍" class="headerlink" title="光棍"></a>光棍</h2><p>再闲谈下<strong>光棍</strong>吧，有个段子：</p>
<blockquote>
<p>从前喜欢一个人，现在喜欢一个人。</p>
</blockquote>
<p>中文还是博大精深呀。这段子怎么看都是光棍修炼着修炼着，提升了一个境界。再修炼下去是不是要变成魔法师了。不瞒你说，本人目前已经是到了”现在喜欢一个人“的境界了，也算是有点小资格来谈下这个事情了。</p>
<h3 id="从前喜欢一个人"><a href="#从前喜欢一个人" class="headerlink" title="从前喜欢一个人"></a>从前喜欢一个人</h3><p>从前哪只喜欢一个人呀，男人都是很花心的，尤其是年轻的男孩，见几个爱几个。</p>
<p>哎，回忆突然塞满了脑子，但是啥也写不出来。不写了。</p>
<h3 id="现在喜欢一个人"><a href="#现在喜欢一个人" class="headerlink" title="现在喜欢一个人"></a>现在喜欢一个人</h3><p>现在确实喜欢一个人。</p>
<p>每周一听同事炫耀周末跟妹纸去逛街的“乐趣”，私下庆幸自己没有妹纸。只怨自己天生是平足，逛街于我实在顶残忍的酷刑。</p>
<p>再者，我们读书人，向来是以追求自由独立为目标的，经济自由独立，活动自由独立，思想自由独立。倘使交了朋友，总要有所妥协，经济要受其管制，假期活动被其安排，脑子要求只有她，何来自由独立之思想，甚至可怕，可怕，可怕。</p>
<p>那一直是一个人，都自由独立了嘛？<strong>没有！</strong>这才是悲剧所在。</p>
<p>其实内心还是渴望爱情，但是已没有年少时只要姑娘点头，其他全部抛掉的勇气了。现在喜欢一个人的原因也只是不爱那位同事所“炫耀”的那种生活（我们汪类看来那就是炫耀）。</p>
<p>所以一直对外宣称自己是姐姐控，只是因为感觉上的姐姐都是那么得独立自主，即使两个人，也不用一直腻歪在一起，依然可以有可以自己的空间与时间。</p>
<p>但是都不腻歪在一起了，还怎么谈朋友，简直是太可恶，可恶，可恶。</p>
<p>这样的矛盾，估计是注定孤独一生了。</p>
<h1 id="书读得越多越蠢"><a href="#书读得越多越蠢" class="headerlink" title="书读得越多越蠢"></a>书读得越多越蠢</h1><p>记得看过一张图，找了下没找到，大概描绘下：图片一边是一摞书，堆很高。另一边对应三层大气，自下而上是近地面：风景秀丽，对流层：电闪雷鸣，平流层：拨云见日。大概的意思是，如果稍微读点书，会经历那一层电闪雷鸣，有足够的积累的人才可以冲破乌云，看到云上的壮阔景象。</p>
<p>问题是，局中人永远看步到自己所处位置的，所以无法知晓自己还离穹顶有多少步。悲哀呀悲哀。</p>
<p>好了，终于为自己的越来越愚蠢找了个高大上的借口。</p>
<p>工作后看书也不太看了，基本也就是电影电视剧看太多感到羞愧的时候，捧起本粗浅的小说来看几眼，再拿起一旁手机看几十眼。断断续续也算看了几个小故事吧。</p>
<h2 id="阿城"><a href="#阿城" class="headerlink" title="阿城"></a>阿城</h2><p>阿城之前也没听过，记得大四那年看了梁文道的一档节目，其中有一期推荐阿城的《<a href="https://book.douban.com/subject/26586889/" target="_blank" rel="noopener">阿城精选集</a>》，就一直放在<em>想读</em>的清单里。16年下半年的某一天吧，某东搞图书类的促销活动，凑了几本，其中便有这本。</p>
<p>阿城本身也是个很惜字的人，这书也不厚，大概十几万字吧，换成狗血的网文，估计也就两个小时看完了吧。也怪我不是有恒心一口气看完，居然断断续续看了一年，也是罪过。亏得里面都是些一两页的小短文。</p>
<p>阿城的文字实在是有特点得很，描写含而不发，十分隐忍，加上其自身中西贯通，又上山下乡过，可谓见识远博。文章的情节设置看似朴实无华，却又五味无穷，这等出神入化的功力实在是叹为观止。其中《棋王》，《树王》，《孩子王》最为著名，虽然每篇都很短，顶多算个中篇，但总是可以凭几句看似随意的一个细节或者一个动作的描写，把人物和情节描写的入木三分。</p>
<p>阿城的文字初读感觉只是描述了情节，细想却似描绘了但是社会下人们的生活状态，再想下就要联系到浩荡的历史长河了。实在是像有魔法一般。</p>
<h2 id="白先勇"><a href="#白先勇" class="headerlink" title="白先勇"></a>白先勇</h2><p>白先勇之前也不太了解，可能有时会看到他和红楼梦经常联系在一起吧。已经记不清是什么时候听的《锵锵三人行》中，有谈到了白先勇《<a href="https://book.douban.com/subject/5337248/" target="_blank" rel="noopener">台北人</a>》中的一些情节，讲述随国民党去台湾的一些老兵的故事，觉得有些意思，就放在了<em>想读</em>的清单里。</p>
<p>16年春节过完后，回厦门的动车上，看完了《台北人》。</p>
<p>白先勇先生的父亲是著名的国民党著名将领白崇禧，曾任“中华民国国防部部长”，后随国民党退居台湾。白先勇经历了和曹雪芹类似的家族从巅峰慢慢衰落的过程，可能也因此白先勇十分推崇红楼梦。</p>
<p>《台北人》主要讲述了从大陆随国民党迁居到台湾的各层阶级，各类职业的故事。通篇还是非常悲情的，各种思乡离愁，生活艰辛，各种往昔美好生活和当前残败生活的对比，白先勇本身特殊的身份让他可以观察到各种人群的生活状态，并述诸于文字。</p>
<p>白先勇描写不仅有画面感，而且还有声音。开篇几篇均是迁居台湾最后客死他乡的上海人的故事，其对话用上海话演绎也没有问题。可以说是传神的很。通篇基本没有直接抒情，均是描写性和记录性的文字，但是那种失落感和追忆往昔的感情缺失扑面而来。这点可以说跟阿城有点像。</p>
<p>我是没有看过《红楼梦》，一直看了几章就放弃了，但是白先勇的写法跟《红楼梦》还有些类似的，其中对于人物，衣着，家具的描写和《红楼梦》的“头上戴着束发嵌宝紫金冠…”很是类似的。（既然如此，为什么《台北人》可以看完，《红楼梦》怎么看不下。）</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>Samsung版的kindle送了一本《<a href="https://book.douban.com/subject/26803179/" target="_blank" rel="noopener">平原上的摩西</a>》，作者是双雪涛。这个名字实在是没听过，百度了下，算是新锐作家。不过这篇《平原上的摩西》实在是精彩得很。文字上有些先锋文学的感觉，还带些阿城的感觉，情节虽说不是特别的巧妙，但是叙述的方法很是高明。非常推荐。</p>
<p>《<a href="https://book.douban.com/subject/3402999/" target="_blank" rel="noopener">到灯塔去</a>》，作者是弗吉尼亚·伍尔夫，以前应该学过她的《墙上的斑点》。意识流小说流派的代表作之一。没看完，还在看。第一次看意识流的小说（之前就看几页的《追忆逝水年华》和《繁华与骚动》不算），跟我想的还不一样。本来以为意识流就是作者想什么就写什么，实际上是在情节里，故事中的人物想什么，就写什么。本身意识流小说还是个小说，只是心理活动的描写更多些而已。现在才认识到这个点，惭愧。</p>
<p>《<a href="https://book.douban.com/subject/2567698/" target="_blank" rel="noopener">三体</a>》，在大刘获雨果奖之前，就已经尝试了不下三次去看这套书了，每次都看到叶文洁到秘密军事基地就看下不去了。大刘的其他的短篇小说倒是都被我看完了。确实十分得精彩。应该找时间再一次尝试《三体》了。</p>
<p>最近在看郁达夫的一些中短篇的小说，主要按照<a href="https://book.douban.com/subject/2010284/" target="_blank" rel="noopener">这本集子</a>看。郁达夫的小说怎么这么颓丧，跟以前课本的《故都的秋》感觉完全不一样。倒是让我联想到之前关于闽南语歌曲的一个段子：</p>
<blockquote>
<p>闽南语歌曲三大主题：老娘要男人、我命怎么那么苦、老子一定会成功。</p>
</blockquote>
<p>郁达夫的小说的主题倒是跟闽南语歌曲前两个主题很相似：我要女人，我好苦。关键没有最后那个我一定会成功。啊哈哈~</p>
<p>看了几篇，意思都是：好想跟那个女人发生关系，但是我不能祸害她，这都是这个社会的错，我要复仇。有趣，有趣，有趣。</p>
<p>另外还有些描写战争年代下的人们生活的小说，由于郁达夫也是浙江人，有些描写看了也是特别的亲切。郁达夫的文字还是很有水平的，如果情绪不是很消极的情况下，看下还是可以的，如果自身很颓丧，再看郁达夫的小说，估计要忧郁症了。</p>
<h1 id="英语问题"><a href="#英语问题" class="headerlink" title="英语问题"></a>英语问题</h1><p>英语是基本荒废了，尝试抢救了几次，感觉像是抢救不过来了。</p>
<p>语言说到底只是个工具，工具不用的话，肯定会生疏的。现在的状态，听说基本就是废了。写的话，基本靠词典，基本只会简单单词和句子了。终于读还能读些。可悲，可悲，怎么有种以前英语很好的错觉。</p>
<p>英语还是很重要滴，手机上下了个APP，就坚持一个礼拜，应该要重拾起来呀。废物，废物，废物。</p>
]]></content>
      <tags>
        <tag>痴人说梦</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK初体验</title>
    <url>/2017/09/24/meet-ELK/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    近期遇到有分日志数据需要分析，计算部分不算复杂，直接shell脚本跑一遍大致也可以完成，但是其数据维度较多，分析结果不易展示。希望可以导入数据库，按照需要sql提取数据，进行展示。</p>
<p>​    对于笔者这种没有开发经验的小白来说，做这么系统是天方夜谭了。<em>（认清现实呀）</em></p>
<p>​    所以必须得有现成的解决方案的，附上条件：</p>
<ul>
<li><p>开源的，可不希望为了这个付出大代价；</p>
</li>
<li><p>比较流行的，对于小白来说，肯定会遇到各种问题，所以最好有各种教程，有论坛；</p>
<p>​百度、google都可以，很容易就可以找到今天的主角，<strong>ELK</strong>，也就是<code>elasticsearch+logstash+kibana</code>。</p>
</li>
</ul>
<a id="more"></a>



<h1 id="ELK是什么？"><a href="#ELK是什么？" class="headerlink" title="ELK是什么？"></a>ELK是什么？</h1><p>​    小白对于ELK的理解比较简单，大概是这样：    </p>
<p>​    ELK是三个独立组件组成一套数据接收，处理（简单处理），存储，以及展示的系统。</p>
<p>​    其中的优点是：</p>
<ul>
<li><p>完成部署后，是实时处理数据的，十分便捷；</p>
</li>
<li><p>听说elasticsearch可以分布式部署，运作，可用性和承载量很高；（小白啥也不知道，你说好用就好用吧）</p>
</li>
<li><p>部署简单，基本就解压就可以用了；</p>
<p>其架构大概如此：</p>
</li>
</ul>
<div id="flowchart-0" class="flow-chart"></div>

<h1 id="安装ELK"><a href="#安装ELK" class="headerlink" title="安装ELK"></a>安装ELK</h1><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p>​    本次使用的为单台的CentOS 5.8的物理机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Distributor ID:	CentOS</span><br><span class="line">Description:	CentOS release 5.8 (Final)</span><br><span class="line">Release:	5.8</span><br><span class="line">Codename:	Final</span><br></pre></td></tr></table></figure>

<h2 id="java环境"><a href="#java环境" class="headerlink" title="java环境"></a>java环境</h2><p>​    另外这套系统全部由运行在java上，所以需要java1.8的环境，具体安装不再赘述，参考<a href="http://www.cnblogs.com/zeze/p/5902124.html" target="_blank" rel="noopener">这篇博文</a>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># java -version</span></span><br><span class="line">java version <span class="string">"1.8.0_144"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_144-b01)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)</span><br></pre></td></tr></table></figure>

<h2 id="安装ELK-1"><a href="#安装ELK-1" class="headerlink" title="安装ELK"></a>安装ELK</h2><p>​    安装上文已经介绍了，非常简单，在<a href="https://www.elastic.co" target="_blank" rel="noopener">ELASTIC官网</a>下载，下载解压即可。</p>
<p>​    本次使用的版本是：</p>
<ul>
<li>elasticsearch-5.5.2</li>
<li>logstash-5.5.2</li>
<li>kibana-5.5.2</li>
</ul>
<h2 id="配置启动"><a href="#配置启动" class="headerlink" title="配置启动"></a>配置启动</h2><h3 id="logstash"><a href="#logstash" class="headerlink" title="logstash"></a>logstash</h3><p>​    logstash进行简单的配置之后，就可以直接运行了。</p>
<h4 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h4><p>​    按照惯例会使用最简单的std输入和std输出测试logstash能否正常工作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./logstash-5.5.2/bin/logstash -e <span class="string">'input&#123;stdin&#123;&#125;&#125;output&#123;stdout&#123;codec=&gt;rubydebug&#125;&#125;'</span></span><br></pre></td></tr></table></figure>

<p>​    在标准输入中输入内容。比如<code>test</code>，会在标准输出打印先相关内容。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "@timestamp" =&gt; 2017-09-19T15:24:24.021Z,</span><br><span class="line">      "@version" =&gt; "1",</span><br><span class="line">          "host" =&gt; "localhost",</span><br><span class="line">       "message" =&gt; "test"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    其中<code>@timestamp</code>字段是事件发生的时间，默认会添加。</p>
<h4 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h4><p>​    编辑该配置文件<code>./logstash-5.5.2/config/logstash.conf</code>，填入logstash的输入<code>input{}</code>，处理<code>filter{}</code>，输出<code>output{}</code>信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">input&#123;</span><br><span class="line">  <span class="comment">#输入相关配置</span></span><br><span class="line">&#125;</span><br><span class="line">filter&#123;</span><br><span class="line">  <span class="comment">#数据处理相关配置</span></span><br><span class="line">&#125;</span><br><span class="line">output&#123;</span><br><span class="line">  <span class="comment">#输出相关配置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="input"><a href="#input" class="headerlink" title="input{}"></a>input{}</h5><p>​    <code>input{}</code>即输入相关配置，logstash支持文件形式(<code>file</code>)，标准输入(<code>stdin</code>)，syslog协议(<code>syslog</code>)，tcp(<code>tcp</code>)四种方式。</p>
<p>​    <code>input</code>还支持常见的数据格式，如json，需要使用<code>codec</code>插件，详细不赘述。可以查看<a href="https://www.elastic.co/guide/en/logstash/current/input-plugins.html" target="_blank" rel="noopener">官网</a>学习。</p>
<h5 id="filter"><a href="#filter" class="headerlink" title="filter{}"></a>filter{}</h5><p>​    <code>filter{}</code>即logstash中的数据处理部分，主要有各类丰富的插件完成。这边介绍下使用的常见的几个：</p>
<h6 id="grok"><a href="#grok" class="headerlink" title="grok"></a>grok</h6><p>​    <code>grok</code>可以编码各种正则来提取所需要的信息，并且可以指定数据的格式。其基本语法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  grok &#123; match =&gt; &#123; <span class="string">"message"</span> =&gt; <span class="string">"Duration: %&#123;NUMBER:duration&#125;"</span> &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    其中<code>NUMBER</code>是事先编写好的pattern，或者是自带的pattern，上例的含义为，将<code>Duration:</code>后符合<code>NUMBER</code>pattern的数据赋值给<code>duration</code>。</p>
<p>​    <code>grok</code>详细操作与介绍可以参考<a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-grok.html" target="_blank" rel="noopener">grok官方介绍</a>。</p>
<h6 id="date"><a href="#date" class="headerlink" title="date"></a>date</h6><p>​    <code>date</code>插件可以将日期和时间格式的数据转化成想要的格式，其中也内置很多标准的格式，其基本语法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  date &#123;</span><br><span class="line">    match =&gt; [ <span class="string">"logdate"</span>, <span class="string">"MMM dd yyyy HH:mm:ss"</span> ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上例的含义为，将<code>logdate</code>的日志格式转为<code>MMM dd yyyy HH:mm:ss</code>的形式。</p>
<p>​    <code>date</code>详细操作与介绍可以参考<a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-date.html" target="_blank" rel="noopener">date官方介绍</a>。</p>
<h6 id="json"><a href="#json" class="headerlink" title="json"></a>json</h6><p>​    <code>json</code>插件可以对<code>grok</code>match到的变量进行json解格式，其基本用法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">  json &#123;</span><br><span class="line">    <span class="built_in">source</span> =&gt; <span class="string">"message"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上例的含义为，将<code>source</code>解json。</p>
<p>​    <code>json</code>详细操作与介绍可以参考<a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-json.html" target="_blank" rel="noopener">json官方介绍</a>。</p>
<h6 id="split"><a href="#split" class="headerlink" title="split"></a>split</h6><p>​    <code>split</code>可以将某一事件按照某个字符进行拆分，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filter &#123;</span><br><span class="line">    split &#123;</span><br><span class="line">        field =&gt; <span class="string">"message"</span></span><br><span class="line">        terminator =&gt; <span class="string">"#"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    上例的含义为，将<code>message</code>field按照<code>#</code>进行拆分。</p>
<p>​    <code>split</code>详细操作与介绍可以参考<a href="https://www.elastic.co/guide/en/logstash/current/plugins-filters-split.html" target="_blank" rel="noopener">split官方介绍</a>。</p>
<h6 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h6><p>​    关于<code>filter</code>其他插件以及使用方法，可以查看<a href="https://www.elastic.co/guide/en/logstash/current/filter-plugins.html" target="_blank" rel="noopener">这里</a>。</p>
<h5 id="output"><a href="#output" class="headerlink" title="output{}"></a>output{}</h5><p>​    logstash支持非常多的输出选项，输出到文件，输出到stdout，输出到端口，输出到email等，比如常见的输出到<code>elasticsearch</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        hosts =&gt; [<span class="string">"192.168.0.2:9200"</span>]</span><br><span class="line">        index =&gt; <span class="string">"logstash-%&#123;type&#125;-%&#123;+YYYY.MM.dd&#125;"</span></span><br><span class="line">        document_type =&gt; <span class="string">"%&#123;type&#125;"</span></span><br><span class="line">        flush_size =&gt; 20000</span><br><span class="line">        idle_flush_time =&gt; 10</span><br><span class="line">        sniffing =&gt; <span class="literal">true</span></span><br><span class="line">        template_overwrite =&gt; <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>elasticsearch</code>输出参数非常多，可定制性也很强，可以从<a href="https://www.elastic.co/guide/en/logstash/current/plugins-outputs-elasticsearch.html" target="_blank" rel="noopener">elasticsearch官方介绍</a> 了解详细的信息。</p>
<p>​    其他形式的输出也可以从<a href="https://www.elastic.co/guide/en/logstash/current/output-plugins.html" target="_blank" rel="noopener">output官方介绍</a>了解。</p>
<h5 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h5><p>​    关于logstash的其他配置和功能，可以查看其<a href="https://www.elastic.co/guide/en/logstash/current/index.html" target="_blank" rel="noopener">官方教程</a>。 </p>
<h4 id="启动logstash"><a href="#启动logstash" class="headerlink" title="启动logstash"></a>启动logstash</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./logstash-5.5.2/bin/logstash -f ./logstash-5.5.2/conf/logstash.conf</span><br></pre></td></tr></table></figure>

<h3 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h3><p>​    elasticsearch经过简单配置，直接运行即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ./config/elasticsearch.yml </span><br><span class="line">...</span><br><span class="line"><span class="comment">#修改cluster名称</span></span><br><span class="line">cluster.name: test_cluster</span><br><span class="line"><span class="comment">#修改node名称</span></span><br><span class="line">node.name: node-1</span><br><span class="line"><span class="comment">#填写IP</span></span><br><span class="line">network.host: ***.***.***.***</span><br><span class="line"><span class="comment">#填写端口</span></span><br><span class="line">http.port: 9200</span><br></pre></td></tr></table></figure>

<p>​    其他配置根据需要配置。总体来说配置的内容较少。直接启动程序，测试9200是否可以正常运行。    </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/elasticsearch</span><br><span class="line">curl http://***.***.***.***:9200/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span> : <span class="string">"node-1"</span>,</span><br><span class="line">  <span class="string">"cluster_name"</span> : <span class="string">"test_cluster"</span>,</span><br><span class="line">  <span class="string">"cluster_uuid"</span> : <span class="string">"lIW3ERtnQGqoXd_fPZgr6Q"</span>,</span><br><span class="line">  <span class="string">"version"</span> : &#123;</span><br><span class="line">    <span class="string">"number"</span> : <span class="string">"5.5.2"</span>,</span><br><span class="line">    <span class="string">"build_hash"</span> : <span class="string">"b2f0c09"</span>,</span><br><span class="line">    <span class="string">"build_date"</span> : <span class="string">"2017-08-14T12:33:14.154Z"</span>,</span><br><span class="line">    <span class="string">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"lucene_version"</span> : <span class="string">"6.6.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    返回es的一些信息，表示es正常运行。</p>
<p><strong>注意事项:</strong></p>
<p>​    ES本身不允许root运行，并且对于运行有些条件。如果机器性能达不到要求，可以在<code>./configjvm.options</code>中调低java运行参数。</p>
<p>​    另外，如果有以下报错，请更改响应的参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ERROR: [3] bootstrap checks failed</span><br><span class="line">[1]: max file descriptors [4096] <span class="keyword">for</span> elasticsearch process is too low, increase to at least [65536]</span><br><span class="line">[2]: max number of threads [1024] <span class="keyword">for</span> user [elk] is too low, increase to at least [2048]</span><br><span class="line">[3]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl -w vm.max_map_count=262144</span><br><span class="line">vim /etc/security/limits.conf</span><br><span class="line">elk soft nofile 65536</span><br><span class="line">elk hard nofile 65536</span><br><span class="line">elk soft nproc 2048</span><br><span class="line">elk hard nproc 4096</span><br></pre></td></tr></table></figure>

<p>​    出现以下报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">system call filters failed to install; check the logs and fix your configuration or <span class="built_in">disable</span> system call filters at your own risk</span><br></pre></td></tr></table></figure>
<p>​    因为Centos6不支持SecComp，导致启动失败，详情可以看github这个<a href="https://github.com/elastic/elasticsearch/issues/22899" target="_blank" rel="noopener">issue</a>。</p>
<p>​    解决办法是关闭下面两个选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ./config/elasticsearch.yml </span><br><span class="line">bootstrap.memory_lock: <span class="literal">false</span></span><br><span class="line">bootstrap.system_call_filter: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="kibana"><a href="#kibana" class="headerlink" title="kibana"></a>kibana</h3><p>​    kibana经过简单配置，直接运行即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ./config/kibana.yml</span><br><span class="line">...</span><br><span class="line"><span class="comment">#配置端口</span></span><br><span class="line">server.port: 5601</span><br><span class="line"><span class="comment">#配置host</span></span><br><span class="line">server.host: <span class="string">"***.***.***.***"</span></span><br><span class="line"><span class="comment">#配置es查询地址</span></span><br><span class="line">elasticsearch.url: <span class="string">"http://124.164.8.39:9200"</span></span><br></pre></td></tr></table></figure>

<p>​    其余配置项可以保留默认值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./bin/kibana</span><br><span class="line"><span class="comment">#curl探测成功即可。</span></span><br><span class="line">curl -I http://124.164.8.39:5601</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">kbn-name: kibana</span><br><span class="line">kbn-version: 5.5.2</span><br><span class="line">cache-control: no-cache</span><br><span class="line">Date: Sun, 24 Sep 2017 08:05:21 GMT</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>kibana界面：</p>
<p><img src="/images/20170924.png" alt="kibana界面"></p>
<p>kibana绘图：</p>
<p><img src="/images/20170924_2.png" alt="kibana绘图"></p>
<p>其他功能研究中~</p>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: origin
e=>end: browser
op1=>operation: logstash处理数据后发送ES
op2=>operation: ElasticSearch
op3=>operation: kibana从ES读取数据展示

st->op1->op2->op3->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12,"theme":"simple"}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      <tags>
        <tag>LINUX</tag>
        <tag>analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>十一月的一些小想法（三）</title>
    <url>/2017/11/25/meander-in-November-3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>书接上回。</p>
<p>想这么多有的没的，实在是丢人现眼，讲点正事吧。</p>
<h1 id="关于笔记"><a href="#关于笔记" class="headerlink" title="关于笔记"></a>关于笔记</h1><p>上半年以来，公司开始对于员工权限做各种限制与规范，对于网盘和USB也有限制。对于工作效率和公司内部资料安保的取舍不做评价。要吐槽的是，公司也禁止了各种云笔记，确实不方便的很。互联网诞生于自由分享，确乎现今的主题早已不是自由分享了。</p>
<a id="more"></a>

<p>关于笔记软件，其实接触得还是蛮早的，在12年就开始使用有道云笔记记录些奇奇怪怪的东西了。不过学生时代真的要记的东西少得可怜，多的倒是些无病呻吟的絮叨。现在已经不忍心打开看了，太羞耻😅。</p>
<p>13年的时候，参加一场关于设计的讲座分享，一位姑娘的案例是印象笔记。Evernote中文翻译成印象笔记，不仅跟logo契合，而且有个说法是大象永远不会忘记，翻译成印象笔记十分巧妙，浑然天成。这点我倒是也永远不会忘记了。于是乎，也用了段时间的印象笔记。随着印象笔记慢慢更新迭代，其功能越来越复杂，也越来越吃资源，用得越来越少。</p>
<p>15年，大三好多课没选上，没事干，居然萌生了写本小说的妄想😂。咸鱼淘了台Microsoft的surface，有空就去图书馆码字。小说肯定流产了。不过surface确实惊艳到我了，被别人问起设备是什么的时候也是逼格满满。也让我第一次接触了到OneNote。</p>
<p>不得不说，office的生态太无敌，OneNote出生就是含着金汤匙的。作为Android和IOS的顶级开发者和自家UWP平台的一般般开发者，OneNote本身多平台的应用质量还是非常不错的。linux就不管了，才不装逼的用linux系统办公呢。除了不支持markdown以及复制默认粘贴图片外，对于我来说基本已经满足了。markdown没有也问题不大，基本排版OneNote也是很方便的。重要的是免费和后面有微软爸爸，放心。</p>
<p>之后到工作至今，一直使用的是OneNote，随着笔记条数越来越多，惯性也随之变大，已经不能像以前一样随便从云笔记A迁到云笔记B了。因此笔记及时整理和笔记的分门别类变得尤为重要。</p>
<p>工作以后OneNote里塞了一堆东西，基本都放在几个tab里，数量多了之后严重影响了后续查阅，终于还是花了一个周六，把OneNote整理了下，删除了大量乱七八糟已经没有用的记录，将一些记录进行归档，使得整个笔记本更有层次。具体怎么整理是每个人自己的想法问题了，从没有定论。贴张图😜</p>
<p><img src="/images/20171125001.png" alt="OneNote"></p>
<h1 id="工具技能"><a href="#工具技能" class="headerlink" title="工具技能"></a>工具技能</h1><p>工作当中，经常需要从大量的日志中分析某些指标，排查问题。常规的工具，Excel和shell已经足够。linux内置的awk、sed等工具已经足够强大到可以满族几乎所有的日常日志数据处理需要。</p>
<p>所以也一直没有考虑是否要学习另外的工具。</p>
<p>近期遇到个场景是，需要将多个终端的数据实时同步一台中心机器上。而公司的机器都有安全限制，无法自行安装软件，且终端数量较多，不方便操作。考虑过将数据落地到磁盘，定时起个rsync将数据同步到中心机器上。由于安全限制，终端之间无法直接进行rsync操作（获取不到用户权限）。</p>
<p>恰好最近在考虑是不是学习下python，觉得python确实在某些方面有独到的优势。而且python这么多modules，实现某些功能比shell简单太多了。</p>
<p>经同事推荐，大概看了下<a href="https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000" target="_blank" rel="noopener">廖雪峰的python教程</a>，在中心机器上用python起了个简单的HTTPServer，接收终端机器post过来的数据，并做了简单处理。在终端机数量一定的情况，可以满足要求了。</p>
<p>一些感悟：</p>
<ul>
<li>身为产品工程师（公司的职位这么写的😂），有些工具还是最好掌握下的，对于实际工作帮助很大。</li>
<li>python确实是强大的很，但是通用性并不是很好，在类似公司这里限制很强的机器上并不一定都能跑起来。而shell虽然有些功能难以实现，但是通用性非常强，基本脚本实在另一台机器上跑。</li>
<li>工具只是工具而已，并不需要执着某个工具，抱有一个工具吃遍天下的想法。也不用什么工具都想要知道，搞得学了一堆杂七杂八的东西。实际还是需求驱动是最好，能够快速解决问题的工具就是最好的。</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><p>直播发展至今，功能上来说，各家解决方案提供商也趋于一致。已经到了开始比拼质量的阶段了。比如传输层协议，tcp/ip协议簇。</p>
<p>tcp内核传输一些策略可能会影响到客户端接收数据，在直播这样较为敏感的场景下，导致了卡顿。因为tcp内核的一些参数也需要进行特定的调整。google的tcp/ip拥塞控制算法是比较流行的一套方案，可以实时基于发送速率和RTT调整tcp窗口和速率，实现对拥塞的快速响应。</p>
<p>由于并不是科班出身，对这些东西基本就知道几个概念，既然用得着，得找时间好好了解下网络传输的协议。这篇<a href="https://read.douban.com/column/1788114/" target="_blank" rel="noopener">《协议森林》</a>可以好好看看，很适合我这样没有基础的。</p>
<p>另外http和rtmp这类更高级的协议也应该多多了解些。可以更好地理解整个数据传输过程。</p>
<h2 id="工作成果展示"><a href="#工作成果展示" class="headerlink" title="工作成果展示"></a>工作成果展示</h2><p>每周五都要写周报。有个问题是，经常发现比较重要的事情，领导似乎都不太关心，而随便提了一句的事情，领导可能会私聊来了解情况。看来每个人的关注点都不太一样，写周报这类工作进展的东西，<strong>并不能按照自己的实际工作时间来侧重。</strong>具体写啥，是门艺术，得好好琢磨。</p>
<h2 id="发散思维"><a href="#发散思维" class="headerlink" title="发散思维"></a>发散思维</h2><p>近期有个客户一直投诉质量差，需要进行调优。常规的调整策略都使用了，没啥用。</p>
<p>感觉已经黔驴技穷了，所以这个时候，需要各种头脑风暴和奇思妙想了。很多事情并不是都有套路的，说不定答案就在拉💩的灵光一闪。</p>
<h2 id="WebRTC"><a href="#WebRTC" class="headerlink" title="WebRTC"></a>WebRTC</h2><p>最近这个词经常看到，这套方案似乎特别适合做直播连麦，找时间可以了解下。（又是google的，这么强）</p>
]]></content>
      <tags>
        <tag>痴人说梦</tag>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>H264码流中的avcC和Annex-B</title>
    <url>/2018/01/21/avcC-annexB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近期竞答直播火热，简直百花齐放，各大直播解决方案提供商为了快速抢占份额，提出各种降低延迟，同步答题卡与直播画面的方案。</p>
<p>其中，同步答题卡与直播画面的方案中，比较普遍的做法是在H264码流的SEI中增加相应的自定义信息，使得播放器在解码到对应的信息的时候弹出预先几秒下发的答题卡，并开始倒计时。</p>
<p>在这里，涉及到播放器解码H264码流的方式，播放器使用不同的解码方式可能导致SEI解析失败，甚至画面无法正常播放。</p>
<a id="more"></a>

<h1 id="SEI是什么呢？"><a href="#SEI是什么呢？" class="headerlink" title="SEI是什么呢？"></a>SEI是什么呢？</h1><p>SEI是NALU type为6的NALU，全称为Supplemental enhancement<br>information，直译为补充增强信息，一般称为增强帧。此处涉及到比较基础的编码打包方面的知识，笔者也不太清楚，后续查阅资料搞明白之后与大家分享。今天先理下H264打包码流的两种格式：avcc与annex-B。</p>
<h1 id="H264编码结构"><a href="#H264编码结构" class="headerlink" title="H264编码结构"></a>H264编码结构</h1><p>要说H264的打包方式，首先要讲下H264的编码结构。</p>
<p>H264主要分为两层：编码层(Video Coding Layer，VCL)和网络抽象层(NetworkAbstraction Layer (NAL))；前者定义了各种编码的算法，后者将前者编码的数据按照一定的方式进行打包存储或者传输。</p>
<p>而NAL单元(NALU)作为可以单独可以解码的结构，整个H264的码流可以理解为由多个NALU组成的。</p>
<p><img src="/images/20180121001.png" alt="NAL"></p>
<p>而NALU由头部和负荷组成。</p>
<p><img src="/images/20180121002.png" alt="NALU"></p>
<p>NALU的负荷由称为原始字节序列载荷(Raw Byte Sequence Payload,RBSP)，是由一串数据比特串(String Of Data Bits,SODB)加上末尾的stop-bits（使得整个NALU长度是8的倍数）组成。</p>
<p><img src="/images/20180121003.png" alt="RBSP"></p>
<p>另外，关于RBSP还有一个概念叫(Encapsulation Byte Sequence Packets,RBSP，不清楚要怎么翻译)。这个EBSP是在RBSP的基础上，为了防止编码出来的比特流中有跟分隔NALU的StartCodePrefix(<code>0x00000001</code>)有冲突，导致分隔NALU失败。所以在连续出现两个字节为0时，强制插入一个<code>0x03</code>字节。在解码时，再讲<code>0x03</code>字节删除，还原回去。称为脱壳操作（有中文资料这么称呼，不清楚有没有这么个叫法）。</p>
<p>看到有大神用数学公式概括了以上几个概念的关系。此处start_code为annex-b格式中的分隔符，可能是三字节的0x000001或者四字节的0x00000001，实际来看后者较多，可以认为是下图一个小缺陷。</p>
<p><img src="/images/20180121006.png" alt="SODB-RBSP-NALU-bitstream"></p>
<p><img src="/images/20180121007.png" alt="SODB-RBSP-NALU-bitstream"></p>
<p>NALU头部一个字节表明该NALU的类型，标准定义列表如下：</p>
<table>
<thead>
<tr>
<th><strong>nal_unit_type</strong></th>
<th><strong>Content of NAL unit &amp;RBSP syntax structure</strong></th>
<th><strong>C</strong></th>
<th>NAL unit type class<br>[Annex A]</th>
<th>NAL unit type class<br>[Annex G &amp; H]</th>
<th>NAL unittype class<br>[Annex I]</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Unspecified</td>
<td></td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
<tr>
<td>1</td>
<td>Coded slice of a non-IDR picture<br><em>slice_layer_without_partitioning_rbsp( )</em></td>
<td>2, 3, 4</td>
<td>VCL</td>
<td>VCL</td>
<td>VCL</td>
</tr>
<tr>
<td>2</td>
<td>Coded slice data partition A<br><em>slice_data_partition_a_layer_rbsp( )</em></td>
<td>2</td>
<td>VCL</td>
<td>not applicable</td>
<td>not applicable</td>
</tr>
<tr>
<td>3</td>
<td>Coded slice data partition B<br><em>slice_data_partition_b_layer_rbsp( )</em></td>
<td>3</td>
<td>VCL</td>
<td>not applicable</td>
<td>not applicable</td>
</tr>
<tr>
<td>4</td>
<td>Coded slice data partition C<br><em>slice_data_partition_c_layer_rbsp( )</em></td>
<td>4</td>
<td>VCL</td>
<td>not applicable</td>
<td>not applicable</td>
</tr>
<tr>
<td>5</td>
<td><font color="#FF0000">Coded slice of an IDR picture<br><em>slice_layer_without_partitioning_rbsp( )</em></font></td>
<td>2, 3</td>
<td>VCL</td>
<td>VCL</td>
<td>VCL</td>
</tr>
<tr>
<td>6</td>
<td><font color="#FF0000">Supplemental enhancement information<br><em>(SEI)sei_rbsp( )</em></font></td>
<td>5</td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
<tr>
<td>7</td>
<td><font color="#FF0000">Sequence parameter set<br><em>seq_parameter_set_rbsp( )</em></font></td>
<td>0</td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
<tr>
<td>8</td>
<td><font color="#FF0000">Picture parameter set<br><em>pic_parameter_set_rbsp( )</em></font></td>
<td>1</td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
<tr>
<td>9</td>
<td>Access unit delimiter<br><em>access_unit_delimiter_rbsp( )</em></td>
<td>6</td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
<tr>
<td>10</td>
<td><font color="#FF0000">End of sequence<br><em>end_of_seq_rbsp( )</em></font></td>
<td>7</td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
<tr>
<td>11</td>
<td><font color="#FF0000">End of stream<br><em>end_of_stream_rbsp( )</em></font></td>
<td>8</td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
<tr>
<td>12</td>
<td>Filler data<br><em>filler_data_rbsp( )</em></td>
<td>9</td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
<tr>
<td>13</td>
<td>Sequence parameter set extension<br><em>seq_parameter_set_extension_rbsp( )</em></td>
<td>10</td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
<tr>
<td>14</td>
<td>Prefix NAL unit<br><em>prefix_nal_unit_rbsp( )</em></td>
<td>2</td>
<td>non-VCL</td>
<td>suffix dependent</td>
<td>suffix dependent</td>
</tr>
<tr>
<td>15</td>
<td>Subset sequence parameter set<br><em>subset_seq_parameter_set_rbsp( )</em></td>
<td>0</td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
<tr>
<td>16</td>
<td>Depth parameter set<br><em>depth_parameter_set_rbsp( )</em></td>
<td>11</td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
<tr>
<td>17 – 18</td>
<td>Reserved</td>
<td></td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
<tr>
<td>19</td>
<td>Coded slice of an auxiliary coded picture without partitioning<br><em>slice_layer_without_partitioning_rbsp( )</em></td>
<td>2, 3, 4</td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
<tr>
<td>20</td>
<td>Coded slice extension<br><em>slice_layer_extension_rbsp( )</em></td>
<td>2, 3, 4</td>
<td>non-VCL</td>
<td>VCL</td>
<td>VCL</td>
</tr>
<tr>
<td>21</td>
<td>Coded slice extension for depth view<br><em>component or a 3D-AVC texture view component slice_layer_extension_rbsp( )</em></td>
<td>2, 3, 4</td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>VCL</td>
</tr>
<tr>
<td>22 – 23</td>
<td>Reserved</td>
<td></td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>VCL</td>
</tr>
<tr>
<td>24 – 31</td>
<td>Unspecified</td>
<td></td>
<td>non-VCL</td>
<td>non-VCL</td>
<td>non-VCL</td>
</tr>
</tbody></table>
<hr>
<p>基础知识讲得差不多了，下面进入正题，看下什么是avcc和annex打包方式呢。</p>
<p>以上已经提过，H264的码流有多个NALU组成，那边NALU是如何组成AVCC的呢，每个NALU又该如何去分隔呢，此处便涉及到了AVCC和annex-B两种格式。</p>
<h1 id="avcC"><a href="#avcC" class="headerlink" title="avcC"></a>avcC</h1><p>avcC的码流打包方式是在每个NALU前面添加一个标记NALU长度的字段，该字段可能的长度为1字节或者2字节或者4字节，通常为了保证该字段可以足够描述NALU的长度，会设置为4个字节。</p>
<p>而该字节的长度可以通过解析extradata（也称为sequence header）的头信息来获取，也就是常说的avc头。以下为该头部信息的解析格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">aligned(<span class="number">8</span>) <span class="class"><span class="keyword">class</span> <span class="title">AVCDecoderConfigurationRecord</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">8</span>)</span> configurationVersion </span>= <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">8</span>)</span> AVCProfileIndication</span>;</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">8</span>)</span> profile_compatibility</span>;</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">8</span>)</span> AVCLevelIndication</span>; </span><br><span class="line">	<span class="built_in">bit</span>(<span class="number">6</span>) reserved = ‘<span class="number">111111</span>’b;</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">2</span>)</span> lengthSizeMinusOne</span>; </span><br><span class="line">	<span class="built_in">bit</span>(<span class="number">3</span>) reserved = ‘<span class="number">111</span>’b;</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">5</span>)</span> numOfSequenceParameterSets</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; numOfSequenceParameterSets;  i++) &#123;</span><br><span class="line">		<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> sequenceParameterSetLength </span>;</span><br><span class="line">		<span class="built_in">bit</span>(<span class="number">8</span>*sequenceParameterSetLength) sequenceParameterSetNALUnit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">8</span>)</span> numOfPictureParameterSets</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; numOfPictureParameterSets;  i++) &#123;</span><br><span class="line">		<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> pictureParameterSetLength</span>;</span><br><span class="line">		<span class="built_in">bit</span>(<span class="number">8</span>*pictureParameterSetLength) pictureParameterSetNALUnit;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>( profile_idc  ==  <span class="number">100</span>  ||  profile_idc  ==  <span class="number">110</span>  ||</span><br><span class="line">	    profile_idc  ==  <span class="number">122</span>  ||  profile_idc  ==  <span class="number">144</span> )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">bit</span>(<span class="number">6</span>) reserved = ‘<span class="number">111111</span>’b;</span><br><span class="line">		<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">2</span>)</span> chroma_format</span>;</span><br><span class="line">		<span class="built_in">bit</span>(<span class="number">5</span>) reserved = ‘<span class="number">11111</span>’b;</span><br><span class="line">		<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">3</span>)</span> bit_depth_luma_minus8</span>;</span><br><span class="line">		<span class="built_in">bit</span>(<span class="number">5</span>) reserved = ‘<span class="number">11111</span>’b;</span><br><span class="line">		<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">3</span>)</span> bit_depth_chroma_minus8</span>;</span><br><span class="line">		<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">8</span>)</span> numOfSequenceParameterSetExt</span>;</span><br><span class="line">		<span class="keyword">for</span> (i=<span class="number">0</span>; i&lt; numOfSequenceParameterSetExt; i++) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">unsigned</span> <span class="title">int</span><span class="params">(<span class="number">16</span>)</span> sequenceParameterSetExtLength</span>;</span><br><span class="line">			<span class="built_in">bit</span>(<span class="number">8</span>*sequenceParameterSetExtLength) sequenceParameterSetExtNALUnit;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中第五个字节的最后两位<code>unsigned int(2) lengthSizeMinusOne;</code>便是上述标记NALU长度的字段的长度。</p>
<p>在extrdata中还包含了SPS的个数，SPS的长度和SPS，以及PPS的个数，PPS的长度和PPS。对于解码器来说，上述参数都十分重要。</p>
<h1 id="Annex-B"><a href="#Annex-B" class="headerlink" title="Annex-B"></a>Annex-B</h1><p>Annex-B是指H264的标准文档中的附录B中给的H264码流打包方式。相对于avcC来说，Annex-B打包方式没有固定长度的字段来表明NALU的长度，而是使用固定字符串来作为不同NALU的分隔符，有<code>0x000001</code>和<code>0x00000001</code>，也就是前文提到RBSP时提到过的<code>START CODES</code>。为了为了防止NALU中本身带有<code>0x000001</code>或者<code>0x00000001</code>而导致的解析分隔失败，引入了<code>0x03</code>的防止竞争字节。这种防止竞争操作同样适用与avcC格式。</p>
<p>Annex-B格式中的SPS和PPS也以NALU的方式放在码流的首部，不像avcC需要将SPS和PPS格式化在extrdata中。</p>
<p><strong>后续贴几张十六进制的图</strong></p>
<h1 id="新增flv实例分析2018年1月25日"><a href="#新增flv实例分析2018年1月25日" class="headerlink" title="新增flv实例分析2018年1月25日"></a>新增flv实例分析2018年1月25日</h1><h2 id="AVCsequenceheader"><a href="#AVCsequenceheader" class="headerlink" title="AVCsequenceheader"></a>AVCsequenceheader</h2><p><img src="/images/20180125001.png" alt="SODB-RBSP-NALU-bitstream"></p>
<ol>
<li>00 00 09 <ol>
<li>onMetadata结束位</li>
</ol>
</li>
<li>00 00 02 F8<ol>
<li>previousTagSize</li>
<li>000002F8H=760D，代表前tag长度为760字节</li>
</ol>
</li>
<li>09<ol>
<li>TagType</li>
<li>09H=09D，代表video（12H=18D，script；08H=08D，audio）</li>
</ol>
</li>
<li>00 00 2D<ol>
<li>DataSize</li>
<li>00002DH=45D，代表实际的TagSize长度为45个字节</li>
</ol>
</li>
<li>00 00 00 <ol>
<li>时间戳，单位毫秒</li>
<li>AVC头时间戳为0</li>
</ol>
</li>
<li>00<ol>
<li>扩展时间戳，单位毫秒，作为基本时间戳的补位，补在基本时间戳的高位</li>
<li>AVC头扩展时间戳为0</li>
</ol>
</li>
<li>00 00 00<ol>
<li>StreamId，默认为0，作用不明</li>
</ol>
</li>
<li>17<ol>
<li>前四位为FrameType，此处为1，代表关键帧<ol>
<li>1: keyframe (for AVC, a       seekableframe)</li>
<li>2: inter frame(for AVC, a non       -seekable frame)</li>
<li>3 : disposable inter       frame(H.263only)</li>
<li>4 : generated       keyframe(reserved forserver use only)</li>
<li>5 : video info / command frame</li>
</ol>
</li>
<li>后四位为CodecID，此处为7，代表AVC编码<ol>
<li>1: JPEG (currently unused)</li>
<li>2: Sorenson H.263</li>
<li>3 : Screen video</li>
<li>4 : On2 VP6</li>
<li>5 : On2 VP6 with alpha channel</li>
<li>6 : Screen video version 2</li>
<li>7 : AVC</li>
</ol>
</li>
</ol>
</li>
<li>由于上述的CodecID为7，所以下面为AVCVIDEOPACKET</li>
<li>00<ol>
<li>AVCPacketType，此处为0，代表AVCsequenceheader<ol>
<li>0–AVC sequence header</li>
</ol>
</li>
<li>1–AVC NALU</li>
<li>2–AVC end of sequence</li>
</ol>
</li>
<li>00 00 00<ol>
<li>由于此处是AVCVIDEOPACKET内容，解析为CompositionTime      Offset，含义不明</li>
</ol>
</li>
<li>接下来一串到下一个tag之前的PreviousTagSize都是AVC的内容，AVCDecoderConfigurationRecord。根据14496-15标准解析。</li>
<li>00 00 00 38<ol>
<li>这个tag的大小。38H=56D，代表这个tag长度为56字节。</li>
</ol>
</li>
</ol>
<h2 id="NAL-units"><a href="#NAL-units" class="headerlink" title="NAL units"></a>NAL units</h2><p><img src="/images/20180125002.png" alt="SODB-RBSP-NALU-bitstream"></p>
<ol>
<li>27<ol>
<li>AVC的非inter frame</li>
</ol>
</li>
<li>01<ol>
<li>AVC NALU数据</li>
</ol>
</li>
<li>00 00 00<ol>
<li>由于此处是AVCVIDEOPACKET内容，解析为CompositionTime      Offset，含义不明</li>
</ol>
</li>
<li>00 00 00 09<ol>
<li>下一个NALU的长度为9字节</li>
</ol>
</li>
<li>06<ol>
<li>NALU header为6，代表为NALU type为SEI</li>
</ol>
</li>
<li>00 00 0F 61 1B 9B D9 39<ol>
<li>NAL中的实际内容，此项为SEI的内容。</li>
</ol>
</li>
<li>00 00 02 23<ol>
<li>下一个NALU的长度为223H=563D字节</li>
</ol>
</li>
<li>41 9A … 7E E0<ol>
<li>NALU的内容</li>
<li>其中第一个字节为nal header，包含以下三个内容<ol>
<li>forbidden_zero_bit</li>
<li>nal_ref_idc</li>
<li>nal_unit_type</li>
</ol>
</li>
<li>此处41H=‭01 00 00 01‬B，<ol>
<li>首位是0，符合要求，语法无错误</li>
<li>第二位到第三位是10，代表优先级是2</li>
<li>第四位到第八位为00001B=1D，表示该nal_unit_header=1，代表非IDR不可分区的slice</li>
</ol>
</li>
</ol>
</li>
<li>00 00 02 54<ol>
<li>代表前面flv tag size是254H=596D字节。</li>
</ol>
</li>
</ol>
]]></content>
      <tags>
        <tag>live</tag>
        <tag>video_codec</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/2016/10/30/test/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>this is a comments test script. this is a comments test script. this is a comments test script.</p>
]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx-rtmp流媒体服务器</title>
    <url>/2016/12/25/nginx-rtmp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Nginx是http和反向代理服务器，同时支持邮件协议（IMAP/POP3/SMTP），由俄罗斯程序设计师Igor Sysoev所开发，其代码遵循BSD许可证开源。由于其轻量，占用系统资源少，并发量强的特点，而拥有不少的用户。<br>Nginx-rtmp-module是nginx的一个模块，开源。使用这个模块开源在nginx的基础上快速搭建起一个流媒体服务器。配合ffmpeg开源项目开源实现许多点播和直播的基本功能。</p>
<a id="more"></a> 

<h2 id="功能特点"><a href="#功能特点" class="headerlink" title="功能特点"></a>功能特点</h2><p>Nginx-rtmp架构的流媒体服务器具有以下一些功能特点：（翻译自官网）</p>
<ol>
<li>支持RTMP / HLS / MPEG-DASH协议的视频直播。测试推流可以实现rtmp 和http flv 的推流，hls和dash并没有测试推流；拉流可以实现rtmp 和hls，没有测试http flv 和dash。<br>2.支持flv/mp4格式的视频点播，支持以文件或者http的方式的输入。<br>3.支持两种流的分发模式 push and pull<br>4.可以将多直播流分别录制成flv文件<br>5.支持H264/AAC编码<br>6.支持在线转码     Onlinetranscoding with FFmpeg     转码实现也是exec ffmpeg的，理论上支持一切ffmpeg支持的库。<br>7.支持HLS (HTTP Live Streaming)需要 libavformat (&gt;= 8. 53.31.100) from ffmpeg (ffmpeg.org)<br>8.支持http回调    HTTPcallbacks (publish/play/record/update etc)<br>9.支持特定情况下调用外部程序(exec)        ffmpeg转码即采用这种方式<br>10.使用HTTPcontrol模块来 recording audio/video and dropping clients<br>11.先进内存控制技术，可以在使用少量内存的情况下完成流畅的直播功能。<br>12.可以和以下外部程序协同工作：Wirecast, FMS, Wowza, JWPlayer, FlowPlayer, StrobeMediaPlayback, ffmpeg, avconv, rtmpdump, flvstreamer等。<br>13.统计数据展示在XML / XSL文件中，友好的可读形式。<br>14.支持跨平台 Linux/FreeBSD/MacOS。</li>
</ol>
<h2 id="安装及配置"><a href="#安装及配置" class="headerlink" title="安装及配置"></a>安装及配置</h2><p>以下针对nginx-rtmp服务器的安装以及一些配置项做一下简单介绍。</p>
<h3 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h3><h4 id="nginx-rtmp-module："><a href="#nginx-rtmp-module：" class="headerlink" title="nginx-rtmp-module："></a>nginx-rtmp-module：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget -O nginx-rtmp-module.zip https://github.com/arut/nginx-rtmp-module/archive/master.zip</span><br><span class="line">unzip nginx-rtmp-module.zip</span><br></pre></td></tr></table></figure>
<h4 id="nginx："><a href="#nginx：" class="headerlink" title="nginx："></a>nginx：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.11.6.tar.gz</span><br><span class="line">tar –x zxvf nginx-1.11.6.tar.gz</span><br></pre></td></tr></table></figure>
<h4 id="编译安装："><a href="#编译安装：" class="headerlink" title="编译安装："></a>编译安装：</h4><p>部署nginx-rtmp服务器除了需要nginx本身的一些支撑包和库之外，在configure的时候需要添加<code>nginx-rtmp-module</code>选项。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/nginx --with-http_ssl_module --add-module=/root/nginx-rtmp-module</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>原生的nginx-rtmp的所有功能均在nginx的配置文件<code>/usr/local/nginx/conf/nginx.conf</code>中实现。<br><code>nginx.conf</code>的整体架构：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="comment">#rtmp配置</span></span><br><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>;</span><br><span class="line">        <span class="attribute">chunk_size</span> <span class="number">4000</span></span><br><span class="line">        application app_name &#123;</span><br><span class="line">		…………					#配置项</span><br><span class="line">        &#125;</span><br><span class="line"><span class="attribute">application</span> app_name2 &#123;</span><br><span class="line">		…………					#配置项</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="attribute">application</span> vod &#123;</span><br><span class="line">            <span class="attribute">play</span> /var/flvs;	<span class="comment">#video on demand</span></span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx配置</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">	<span class="attribute">location</span> /hls &#123;</span><br><span class="line">            <span class="comment"># Serve HLS fragments</span></span><br><span class="line">            <span class="section">types</span> &#123;</span><br><span class="line">                application/vnd.apple.mpegurl m3u8;</span><br><span class="line">                video/mp2t ts;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attribute">root</span> /tmp;</span><br><span class="line">            <span class="attribute">add_header</span> Cache-Control <span class="literal">no</span>-cache;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要在<code>rtmp{ }</code>中配置各种流媒体相关的配置，在<code>http{ }</code>中配置各种http相关的配置。各个<code>application</code>独立配置，支持正则匹配。<br>以下介绍一些重要的配置项：</p>
<h3 id="直播基本配置："><a href="#直播基本配置：" class="headerlink" title="直播基本配置："></a>直播基本配置：</h3><h4 id="rtmp推拉流"><a href="#rtmp推拉流" class="headerlink" title="rtmp推拉流"></a>rtmp推拉流</h4><p>在<code>rtmp{ server{ * } }</code>中配置以下内容</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">application</span> mytv &#123;</span><br><span class="line">	<span class="attribute">live</span> <span class="literal">on</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此即配置了发布点为<code>mytv</code> 的直播频道，可以实现rtmp推流和拉流。推拉流地址：    </p>
<pre><code>rtmp://ip:1935/mytv/stream</code></pre><h4 id="hls"><a href="#hls" class="headerlink" title="hls"></a>hls</h4><p>在<code>application mytv { * }</code>中配置以下内容</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">application</span> mytv &#123;</span><br><span class="line">	…………		#省略其他配置</span><br><span class="line">	<span class="attribute">hls</span> <span class="literal">on</span>;</span><br><span class="line">	<span class="attribute">hls_path</span> /tmp/hls;</span><br><span class="line">	<span class="attribute">hls_fragment</span> <span class="number">15s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>http { server{ location /hls { } } }</code>中配置以下内容</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">location</span> /hls &#123;</span><br><span class="line">            <span class="section">types</span> &#123;</span><br><span class="line">                application/vnd.apple.mpegurl m3u8;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="attribute">root</span> /tmp;</span><br><span class="line">            <span class="attribute">add_header</span> Cache-Control <span class="literal">no</span>-cache;</span><br><span class="line">            <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此配置之后，这个即可进行hls拉流.<br>详细的关于hls的其他配置。如切片时间命名设置、是否加密hls等配置可以参考：<br><a href="https://github.com/arut/nginx-rtmp-module/wiki/Directives#hls" target="_blank" rel="noopener"><strong><em>hls配置文档</em></strong></a> </p>
<h4 id="MPEG-DASH"><a href="#MPEG-DASH" class="headerlink" title="MPEG-DASH"></a>MPEG-DASH</h4><p>在<code>application</code>配置段中配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">dash</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">dash_path</span> /tmp/dash;</span><br><span class="line"><span class="attribute">dash_fragment</span> <span class="number">15s</span>;</span><br></pre></td></tr></table></figure>
<p>在<code>http</code>配置段中配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">location</span> /dash &#123;</span><br><span class="line">            <span class="attribute">root</span> /tmp;</span><br><span class="line">            <span class="attribute">add_header</span> Cache-Control <span class="literal">no</span>-cache;</span><br><span class="line">            <span class="comment"># To avoid issues with cross-domain HTTP requests (e.g. during development)</span></span><br><span class="line">            <span class="attribute">add_header</span> Access-Control-Allow-Origin *;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MPEG-DASH 实现方式与HLS类似，具体可以查看：<br><a href="https://github.com/arut/nginx-rtmp-module/wiki/Directives#mpeg-dash" target="_blank" rel="noopener"><strong><em>mpeg-dash配置文档</em></strong></a> </p>
<h4 id="自动转推"><a href="#自动转推" class="headerlink" title="自动转推"></a>自动转推</h4><p>当多台nginx-rtmp 服务器运行时，可以配置把流自动推到其他机器上。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rtmp_auto_push</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">rtmp_auto_push_reconnect</span> <span class="number">1s</span>;</span><br><span class="line"><span class="attribute">rtmp_socket_dir</span> /var/sock;</span><br><span class="line"></span><br><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>;</span><br><span class="line">        <span class="attribute">application</span> myapp &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>此功能没有测试过，未知其具体转推是如何实现的。</strong></p>
<h4 id="录制"><a href="#录制" class="headerlink" title="录制"></a>录制</h4><p>在<code>application mytv { * }</code>中配置以下内容</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">application</span> mytv &#123;</span><br><span class="line">	…………		#省略其他配置</span><br><span class="line">	<span class="comment"># record first 1K of stream</span></span><br><span class="line">            <span class="attribute">record</span> all;</span><br><span class="line">            <span class="attribute">record_path</span> /tmp/av;</span><br><span class="line">            <span class="attribute">record_max_size</span> <span class="number">1K</span>;</span><br><span class="line">            <span class="comment"># append current timestamp to each flv</span></span><br><span class="line">            <span class="attribute">record_unique</span> <span class="literal">on</span>;		<span class="comment">#开启后每个录制文件根据时间命名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他录制选项可参考：<br><a href="https://github.com/arut/nginx-rtmp-module/wiki/Directives#record" target="_blank" rel="noopener"><strong><em>record配置文档</em></strong></a> </p>
<h4 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h4><p>nginx-rtmp 采用调用外部程序ffmpeg 进行转码。需要在<code>application mytv { * }</code>中配置以下内容</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">1935</span>;</span><br><span class="line">        <span class="attribute">application</span> src &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">exec</span> ffmpeg -i rtmp://localhost/src/<span class="variable">$name</span></span><br><span class="line">              -c:a libfdk_aac -b:a <span class="number">32k</span>  -c:v libx264 -b:v <span class="number">128K</span> -f flv rtmp://localhost/hls/<span class="variable">$name_low</span></span><br><span class="line">              -c:a libfdk_aac -b:a <span class="number">64k</span>  -c:v libx264 -b:v <span class="number">256k</span> -f flv rtmp://localhost/hls/<span class="variable">$name_mid</span></span><br><span class="line">              -c:a libfdk_aac -b:a <span class="number">128k</span> -c:v libx264 -b:v <span class="number">512K</span> -f flv rtmp://localhost/hls/<span class="variable">$name_hi</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">application</span> hls &#123;</span><br><span class="line">            <span class="attribute">live</span> <span class="literal">on</span>;</span><br><span class="line">			……</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exec ffmpeg 这样的配置是会在拉流请求转码流的时候触发ffmpeg 拉流转码，在多台机器做流媒体的时候，可以通过exec_pul 和exec_push 来配置在拉流时触发转码或者在推流时触发转码。</p>
<h4 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h4><p>关于调用外部程序，nginx-rtmp 支持多个配置项，参考：<br><a href="https://github.com/arut/nginx-rtmp-module/wiki/Directives#exec" target="_blank" rel="noopener"><strong><em>exec配置文档</em></strong></a> </p>
<h4 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h4><p>在<code>http{ server{ } }</code>中配置可以启用统计信息。 </p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">location</span> /stat &#123;</span><br><span class="line">            <span class="attribute">rtmp_stat</span> all;</span><br><span class="line">            <span class="attribute">rtmp_stat_stylesheet</span> stat.xsl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> /stat.xsl &#123;</span><br><span class="line">            <span class="attribute">root</span> /path/to/stat/xsl/file;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问<code>http://192.168.1.1:8765/stat</code>可以看到当前时间内的各个application 的概况。<br>也可以下载<code>http://192.168.1.1:8765/stat.xsl</code> 进行统计。<br>端口号根据nginx配置而定。<br><img src="/images/20161225.png" alt="statistic"></p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>除了原生nginx 自带的<strong>error.log</strong> 和<strong>access.log</strong> 两个日志外，nginx-rtmp-module 模块还有一个<strong>rtmp-aceesss.log</strong> 日志。默认都是在nginx 的安装目录的 <code>/logs</code> 目录中。<br>查阅资料后发现，nginx 应该是可以自定日志的格式的。在配置文件中也可以定义错误日志的级别，有<br><strong>debug | info | notice | warn | error | crit</strong> 几个级别，大概排查问题都利用debug 级别的错误日志。</p>
<h4 id="控制模块"><a href="#控制模块" class="headerlink" title="控制模块"></a>控制模块</h4><p>nginx-rtmp 服务器支持以http的形式从外部对rtmp 进行控制。需要配置以下项。</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">……</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        ....</span><br><span class="line">        <span class="attribute">location</span> /control &#123;</span><br><span class="line">            <span class="attribute">rtmp_control</span> all;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再在需要控制的<code>application</code>中预设好各种参数之后，便可以采用类似接口的形式对某些流进行录制，禁播，重定向之类的操作了。以下展示开始和停止录制的url。</p>
<pre><code>curl &quot;http://localhost:8080/control/record/start?app=myapp&amp;name=mystream&amp;rec=rec1&quot;
curl &quot;http://localhost:8080/control/record/stop?app=myapp&amp;name=mystream&amp;rec=rec1&quot; </code></pre><p>具体的控制说明可以查看：<br><a href="https://github.com/arut/nginx-rtmp-module/wiki/Control-module" target="_blank" rel="noopener"><strong><em>control配置文档</em></strong></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Nginx-rtmp 架构的流媒体服务器实际测试基本功能都有，性能也不错。在配置较差的VPS 上搭建也可以流畅运行，并不占用太多的资源。但是其只能实现简单的功能，实际对于业务以及运营需要改进的地方还有很多。<br>实测nginx-rtmp 服务器在hls 时，播放有时会有卡顿，原因未知；同码率推到其他流媒体服务器，hls 拉流没有卡顿，可能跟推流也有关系。</p>
<h2 id="Q-amp-As"><a href="#Q-amp-As" class="headerlink" title="Q&amp;As"></a>Q&amp;As</h2><p>Q: mpeg dash？<br>A: 类似于apple家的HLS，MPEG-DASH 是基于HTTP的自适应串流方案中的唯一国际标准。也是有小切片和索引文件组成，SC计划在明年支持此协议。  </p>
<p>Q: http callback？<br>A: 在nginx-rtmp 的官方wiki 中描述的http callback 大概意思为客户端发送连接请求时，会发送一个异步http 请求，会使处理暂停，直到返回状态码之后再根据状态码继续连接请求。具体可以查看：<br>*<em><a href="https://github.com/arut/nginx-rtmp-module/wiki/Directives#notify" target="_blank" rel="noopener">https://github.com/arut/nginx-rtmp-module/wiki/Directives#notify</a> *</em> </p>
<p>Q: 多域名配置？<br>A: 网上资料说nginx 本身是可以改写url 的，有可以配置多个域名；nginx-rtmp 服务器没有说明可以支持多域名的配置，目测在做一些修改之后是可以做到支持多域名的。  </p>
<p>Q: 延迟？<br>A: nginx-rtmp 的拉流和推流，延迟在1s左右。在播放器缓冲设置在0时所测。  </p>
]]></content>
      <tags>
        <tag>LINUX</tag>
        <tag>live</tag>
      </tags>
  </entry>
</search>
